{"./":{"url":"./","title":"介绍","keywords":"","body":"docs · wiki 这里将收集前端和后端的面试题，并根据自己的理解提供解答，我们将会持续更新和维护该仓库，跟欢迎你和我们以一起来维护😄😄😄。 表情说明 表情 说明 待添加 😄 持续更新中 ✊ 待完善 👊 已完结 ✌️ web 前端文档 文档名称 标签分类 更新状态 HTML HTML + CSS 待完善 👊 HTML5 HTML + CSS 待完善 👊 CSS CSS 待添加 😄 CSS3 CSS3 待添加 😄 JavaScript 基础 JavaScript 待完善 👊 Ajax Ajax 持续更新中 ✌️ ✊ jQuery 基础 jQuery 待完善 👊 微信小程序 WeChat 待完善 👊 TypeScript 基础 jQuery 待完善 👊 web 前端框架 文档名称 标签分类 更新状态 BootStrap 基础 HTML + CSS 待完善 👊 web 后端文档 文档名称 标签分类 更新状态 EggJS NodeJS 待完善 👊 NodeJS NodeJS 待完善 👊 webpack webpack 待完善 👊 Express NodeJS 待完善 👊 后端文档 文档名称 文档签分类 更新状态 null null null 数据库文档 文档名称 文档签分类 更新状态 null null null 致谢 感谢所有为 docs · wiki 做出贡献的人。 转载说明 可以转载里面的所有面试题用到任何地方，但请添加仓库地址和链接，因为有的转载后不会及时更新，但改仓库会及时的更新。 此开源仓库不收取任何费用，在此 郑重说明不会收取任何费用，也不会授权任何人/机构进行收费，如有收费请及时联系本人 不需要对改库进行爬虫，基本上都是Markdown格式文档，只需要打开浏览器就能访问，如需要什么格式，还请联系我或者提问题。 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-02 19:02:26 "},"web/HTML/":{"url":"web/HTML/","title":"HTML","keywords":"","body":"Web 基础知识 html，专门指网页技术 HTML5 大前端技术 网页 app 桌面程序 数据可视化 VR 网页(pc,pad,phone) app wx 服务器 数据库 HTML5 是 html4.01和XHtml1.0的升级版 XHML1.0的语法更严谨 H5支持两种写法 或 web 与 internt Internet全球计算机互联网俗称：互联网，因特网，交换网，交际网 浏览网页，只是internet上所有服务器中的一项服务www服务 world wide web万维网，访问的网站的服务BBS 论坛 Email 邮件 telnet 远程登录 FTP 上传和下载 C/S C: client 客户端 S: server 服务器 代表作：QQ 梦幻西游 B/S B: browser 浏览器 S: server 服务器 代表作：各类网站 C/S和B/S的区别 1、c/s需要升级 2、b/s不需要升级 web运行原理 web：运行在internet上的B/S结构的应用程序，俗称网站internet：为web运行提供了网络环境 internet：为web运行提供了网络环境 通信协议 规范了数据如何打包和传递 服务器 功能：存储数据，接收用户的请求并作出响应，提供了程序的运行的环境，具备了安全功能 服务产品: TomCat (java) Apache (php) llS (.net) 服务器端的技术 java php nodejs .net python 浏览器 功能：代表用户发送请求，接收到响应解析成图形界面作为html css js的解析器 浏览器的产品 chrome safari firefox Opear IE 浏览器技术 html css JavaScript Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/HTML/HTML.html":{"url":"web/HTML/HTML.html","title":"html快速入门","keywords":"","body":"html快速入门 上班第一天 看文档 接口规范文档 命名规则文档 编码要求 1:3 1:2 :::warning 1:3 1:2 注意：是代码和注释比例 要求 2 行代码一行注释，或 3 行代码 1 行注释 看每个公司规范 ::: 什么是 HTML HTML：HyperText Markup Language 超文本标记语言 超文本，有能力的普通文本就是超文本 语法，使用标记<>包裹 每一种标签都有自己独特的功能 文档类型 html5 定义和用法 声明必须是 HTML 文档的第一行，位于 标签之前。 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 metacharset=\"utf8\" description keyword &nbsp; &copy; &reg; &times; X; sup sub 文本样式 加粗 斜体 删除线 下划线 上标 下标 元素的显示方式 ------------------------- 待添加 ------------------------ 图像和链接 图床 节省本地存储空间缺点 不稳定 绝对路径 完整路径 使用任何网络资源的时候使用绝对路径 通信协议 / 主机名/ 文件目录结构/ 文件名称 优点 不占用本地存储空间 缺点 不稳定 使用本机资源使用绝对路径 项目中不许使用 相对路径 & 绝对路径 相对路径: 即相对于当前文件的路径，前端开发中比较常用的路径表示方法绝对路径: 即主页文件或者目录在硬盘上真正的路径。 符号表示 ``` ./ 代表目前所在的路径 ../ 代表上一层路径 / 开头，代码根目录 参照物 访问图片 1 兄弟关系 直接写文件名 2 子集目录 先进入兄弟文件夹 再引入图片 src=\"img/image/10.png\" 3 父级目录 使用../返回父级目录 src=\"../../img/07.png\" - 优缺点分析 相对路径更方便更改，相对比较灵活，但是如果不慎易造成链接失效，并且容易被人抄袭。 绝对路径的话能避免这个问题，但是灵活性上相对较弱。 :::warning 如果设置的宽高比 不符合图片本身的宽高比 图片会发生失真 宽高只设置一个另外自适应 ::: ## 链接 ```html 返回顶部 href=\"javascript:show()\"> 锚点 锚点是什么页面生做的一个记号通过 a 标签 跳转到这个记号 定义锚点 & 连接到锚点 内容 跳转 h5 写法 不浪费a标签 hz 前端开发概括 6800 VUE--angular --react 学好 12k 有效代码量 25k 40k 45k 50k 代码量保证薪资 8000 IT行业 涨薪速度 NO1 2年 6000*2.5 精致 互联网 6K 15K 封闭式开发 3个月 练人 14000 避免笛卡尔积 内联左联会产生笛卡尔积 发生便是致命 乘法 基站崩溃 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/HTML/table.html":{"url":"web/HTML/table.html","title":"表格","keywords":"","body":"表格 表格语法 html 渲染规则 从上往下逐行渲染 一行三列 简写方式: 表格 保存内存 再统一渲染 table>tr*3>td*4>a{12332} 属性 border 边框线 width 宽 height 高 align 设置表格本身的水平方式 bgcolor 规定规定表格的背景颜色 border-color 表格边框颜色 cellpadding 单元格的内边距(内容到边框编距) cellspacing 设置单元格的外边距(边框到边框的距离) Tr的属性 valign 垂直 align 水平 top/bottom/ middle Td的属性 width 设置单元格宽度 height 会影响当前行 和其他 colspan 跨列 colspan 指定单元格开始 横向向右合并N个单元格 n包含自己被合并的单元格要删除掉 rowspan 跨行 从指定单元格开始 纵向向下合并N个单元格n包含自己被合并的单元格要删除 一列 下下 表格的标题 caption 紧跟 table 行/列的标题 行列标题th 代替 td 内容字体加粗 水平居中 表格复杂应用 行分table thead tbody tfoot 列表 让数据有条理的显示在数据之前添加标识但现在页面布局 经常会用到无序列表 ol li 有序列表 order list list item 有序列表 标题1 标题2 标题3/li> 无序列表 unorder list 标题1 标题2 标题3/li> :::tipul 项目中使用非常频繁 常用于一组相似的内容进行布局和排版 ::: 列表的嵌套 :::warning 在类表中嵌套其他元素【注】所有的嵌套元素必须写在li中 ::: 定义列表 h5属性新标签 计算机 用来计算的仪器 ... ... 显示器 以视觉方式显示信息的装置 ... ... 结构标记 用于网页布局 div h5 新出了一批结构标记 代替 div 做布局 这些结构 与 div 作用一模一样 只是增加了可读性 常用结构标记 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/HTML/form.html":{"url":"web/HTML/form.html","title":"form","keywords":"","body":"form 表单 作用 提供可视化的输入控件 收集用户输入的信息 并提交请求给服务器 :::tip 总结form 自带提交请求收集数据的功能ajax提交请求 需要自己去收集数据 使用ajax 不要使用 form ::: from 组成 前端使用的接口 需要后台开发者先完成前端开发人员需要等待后端开发人员完成接口才能进行编码等待 前段 提供表单控件 与用户交互的可视化控件 接口/user_login后端 后台的接口对提交的数据进行处理 服务器开发人员 写接口 逻辑 连数据库 form 表单的使用 其他方法---使用form表单 目前不许使用delete，put option delete put option ---ajax 才能使用 enctype 作用 指定表单数据的编码方式允许将什么样的数据提交给服务器 取值 text/plain 允许提交普通字符给服务器 multipart/form-data 允许提交文件给服务器 必背 application/x-www-form-urlencoded 允许提交 任意字符给服务器(文件不能为空) 表单控件 在form 表单中能够与用户进行交互的可视化控件 分类 input 标签 基础9中 h5 新标签 10中 textarea 多行文本域 select 和 option 下拉选择框 input 元素 属性 文本和密码框 属性 按钮 Click Me! 单选/复选 name 分组使用 男 女 苹果 香蕉 文件选择框 上传文件使用 method=\"post\" enctype=\"multipart/form-data\" 多行文本框 内容 下拉选项 Volvo Saab Opel Audi 1 变成滚动选择框2 multiple 滚动选择框 可实现多选 --> 其他元素 不透露 浮动框架 在一个html中引入其他html文件 实例 内联框架 本例演示如何创建内联框架（HTML 页中的框架） 新表单元素 搜索类型 数字类型 范围类型 type range max min step步长 颜色类型 日期类型 月份类型 周类型 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/HTML5/":{"url":"web/HTML5/","title":"HTML5","keywords":"","body":"HTML 5 html5新特性(视频(重点)与绘图(重点)) html5 w3c组件 2014 推出一组网页中技术总称 非常丰富/外观/绘图/游戏/特效/多对多聊/.... 重点: (视频/canvas绘图/webSocket) html5 新特性(视频) 基础知识 视频文件格式: .mp4 .flv .webm .ogg ... 解码器:如果浏览器播放指定格式视频需要安装 此种格式视频对应解码器 (软件) a.mp4 --> 浏览器安装 mp4解码器 解决方案:\"格式工厂\" x.mp4->x.flv->x.webm 标准语法: 您的浏览器版本太低，请升级！ 兼容语法 :::warning 注意事项:准备多个视频文件 ::: 浏览器版本太低，请升级! html5新特性(视频)--属性在video 元素添加 常见属性 controls 显示播放视频原生控件(兼容性差) loop 循环播放 muted 静音播放 preload 预加载策略 none:不预加载任何数据 metadata:只预加载元数据 (视频长时/视频第一个画面/视频高度和宽度) auto: 加载元数据并且加载一定时长视频(默认) autoplay 自动播放视频(大多数浏览器支持差) poster: 在播放视频之前显示一张图片(广告) 如果视频暂停广告不再显示 js常见属性方法 必须通过js 程序获取:\"视频对象\"才能执行如下属性方法 -volume:1 // 音量(0~1) -playbackRate // 回放速率(播放速度) // 整数:大于1快放 小于1慢播 -play() // 播放视频 -pause() // 暂停播放 -paused // 表示当前视频播放状态 true // 表示视频暂停 false // 表示视频正在播放 :::tip 为视频元素绑定鼠标离开与移入事件 鼠标移入视频区域显示图片 res/play.png 鼠标移出视频区域隐藏图片 为图片绑定点击事件 播放视频与暂停播放视频切换 视频暂停播放时显示广告，如果播放时隐藏广告 ::: html5新特性(视频)--属性在video事件 canplaythrough // 当视频加载结束后可以播放时触发事件(一次) duration: // 视频时长(秒) ended // 当前视频播放结束(一次) timeupdate // 视频正在播放中(多次) 4/s currentTime: // 当前播放时间点 html5新特性(视频)--属性在video样式(重点) video // 元素有一种样式与图片通用 object-fit // 此属性指定视频在区域内如何显示 fill: // 填充 默认值:将视频拉伸操作填满整个父元素 contain: // 包含 保持原有视频比例,父元素空白区域 conver: // 覆盖 保持原有视频比例,宽度或高度至少有一个 // 与父元素一致 html5新特性-绘图-canvas-(重点) 将复杂数据转换图形方开呈现给用户 网页中绘图三种技术 :::tip svg 用户线段组件图形：针对2D矢量图 特点:矢量图可以无限放大和缩小并且不失真, 缺点:颜色不丰富 canvas 用像素点组件图形：针对2D位图 特点:位图可以不能放大和缩小并且失真, 缺点:颜色细腻 webgl 3D位图 ::: html5新特性-绘图-canvas-(坐标系,单词多) 注意事项:完成 html5技术路径不要用jquery.js html5新特性-绘图-canvas-创建画布 通过标签创建画布 通过js获取画布 var c3 = document.getElementById(\"c3\"); 通过画布获取(画笔对象-上下文对象) var ctx = c3.getContext(\"2d\"); html5新特性-绘图-canvas-矩形 绘制空心矩形(描边矩形) ctx.strokeRect(x, y, w, h); x,y // 空心矩形左上角位置 w,h // 空心矩形宽度和高度 绘制实心矩形(填充矩形) ctx.fillRect(x, y, w, h); 设置实心样式 ctx.fillStyle = \"#f00\"; ctx.fillRect(0,0,100,80); // 生效 ctx.strokeRect(0,0,100,80); // 不生效 设置空心样式 ctx.strokeStyle = \"#00f\"; 清空矩形范围内所有元素 ctx.clearRect(x, y, w, h); 清空画布中所有元素 ctx.clearRect(0, 0, 500, 400) Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/HTML5/canvas.html":{"url":"web/HTML5/canvas.html","title":"canvas","keywords":"","body":"canvas html5新特性--canvas绘图-文本(重点) 常用方法与属性 ```js ctx.strokeText(str, x, y); // 绘制描边文字(空心) str: // 绘制文本 x,y: // 字符串左上角位置(以文本基线为准) ctx.fillText(str, x, y); // 绘制填充文字(实心) ctx.font = \"19px SimHei\"; // 前面文本大小/字体 ctx.textBaseline = \"top\"; // 调整文本基线[top/alphabetic/bottom] ## html5新特性--canvas绘图-路径 (重点) 路径:绘制不规则图形 (复杂) `path`:由多个坐标点组件任意图形,图形本身不可见 可以描边或者填充 ```js ctx.beginPath(); // 开始一条新路径(上一条路径结束) ctx.moveTo(x, y); // 移动到指定点(x,y) ctx.lineTo(x, y); // 从当前点到指定点绘制一条直线(x,y) ctx.stroke(); // 描边 ctx.fill(); // 填充 ctx.closePath(); // 闭合一条路径(结束点到开始点画一条直线) ctx.arc(cx, cy, r, start, end); // 绘制一条圆拱形 cx,cy // 圆心位置(x, y) r // 半径 start // 开始角度 end // 结束角度 // 参数start,end 不使用常用角度完成设置，使用弧度设置 // 角度 0~360 弧度0~2PI // 采用角度转换弧度 90角度*Math.PI/180=弧度 html5新特性--canvas绘图-图像 (重点) 图片可以使用img标准显示网页为什么用canvas[复杂]图片位置:一个软件项目所有图片保存服务器 图片版权 图片数量巨大 操作过程将图片绘制canvas画布上 :::tip 创建图像对象p3 = new Image(); 下载图像 p3.src = \"p3.png\";2ms 为图片绑定事件下载成功 p3.onload = function(){...} 绘制图片 ctx.drawImage(p3,x,y) 绘制图片 ctx.drawImage(p3,x,y,w,h) ::: p3 图片对象 x,y 图片或者文本或者图片左上角位置(原始大小图片) w,h 图片宽度和高度(拉伸) html5新特性--canvas绘图-变形 (重点) canvas绘制时对图片进行旋转操作-rotate(deg) 旋转 旋转画笔对象 旋转轴心在画布原点 旋转角度会有累加操作 deg不同角度弧度 translate(x,y) 移动原点(移动轴心)到指定位置 原则:什么时候使用如下两个方法当画布上绘制一个以上元素时必须使用下面方法 save() 保存画笔状态(原点;角度;颜色;...) restore() 恢复到画笔保存时状态(原点;角度;颜色;..) 画图时:如果画布中有多个(一个以上)元素,画之前先保存状态画之后恢复状态(元素之间不会受到影响) html5新特性--canvas绘图-变形 (弹幕) 弹幕:专业视频网站常用功能 :::tip 当用户在观看视频希望(参与感)发表自己想法 情绪/观点 发表内容转文字浮动视频上方 ::: 理解用户操作 :::tip 输入文字 修改文字大小;修改文字颜色 用户点击\"发送按钮\" 将内容显示视频上方 ::: 项目工作流程!!! :::tip 遇到问题:如果发送文字过多效率有一定影响 解决方案:池子 创建程序结构 当设计大规则项目采用方式: 单一原则(一个程序完成一种任务) 第一个程序:index.html 创建元素 显示视频 画布 加载其它 js 第二个程序:msg.js 完成所有弹幕任务(一家餐厅) 第三个程序:main.js 项目入口程序:调用msg.js 方法(大楼主管) ::: html5新特性-- -变形 (弹幕)-index.html :::tip 视频元素：video 底层 z-index:0 画布元素: canvas 上层 z-index:1 创建输入区域[输入文字区域;文字大小下拉列表;文字颜色下拉列表;发送按钮] 加载main.js 文件(主管) 加载msg.js 文件(一家餐厅) ::: 弹幕视频 视频1 视频2 视频3 视频4 视频5 视频6 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/CSS/":{"url":"web/CSS/","title":"CSS","keywords":"","body":"CSS 概述 什么是 css css:cascading style sheets 层叠样式表，级联样式表，简称为样式表 css 作用 设置html网页中元素的样式 HTML 与 css 的关系 :::tip html：负责网页的搭建，内容的展示(素颜) css:负责网页的修饰。(亚洲四大邪术) 对于元素样式的修饰，W3C建议使用css而不用html的属性 html的属性，代码不能重用，没有可维护性 ::: CSS 的语法规范 使用 css 的方式 行内样式(内联样式) 将css的样式写在元素的style属性中 color: red; /* 字体颜色 */ background-color：yellow; /* 背景颜色 */ font-size:32px; /* 字号大小 */ 语法： 样式声明 由样式属性和样式值组成 样式属性:值; :::tip 内联样式不能重用 内联样式优先级最高 在项目中，基本不用，只有在学习和测试中使用 ::: 内部样式 在head标签中，使用定义内部样式 语法: 选择器{样式声明;样式声明;} 选择器{样式声明} 选择器就是页面能够使用当前样式的条件 div{} p{} img{} span{} :::tip 总结：内部样式，只能在本页面重用 内部样式在项目中用的少，主要用于学习和测试 ::: 外部样式 单独创建一个.css文件，在html文件中的head标签里使用link标签引入这个css文件 其中rel属性必须写，不写就不生效项目中大批量的使用外部样式，但是，学习中用的少 css 样式的特性 继承性 :::tip 大部分的css效果是可以直接被子元素继承的 必须是有层级嵌套关系的元素，才能继承。孩子继承父亲。 a标签的字体颜色，是不继承的 ::: 层叠性 :::tip 可以为一个元素定义多个样式如果样式属性不冲突的时候，可以同时作用到这个元素上 ::: 优先级 :::tip 当样式属性冲突时，根据优先级去应用样式。 默认优先级，有高到低 内联样式 内部样式和外部样式，使用就近原则 浏览器默认样式 解释型语言---代码逐行从上往下运行，后执行会覆盖之前执行的 ::: 调整优先级 :::tip !important 规则h2 { color: red !important; } 写在值和；之间，前面要有空格 意义，我这个值是最重要的，其它的值不要覆盖我 如果有多个!important;，那么还是遵循就近原则 ::: 基础选择器 重点 选择器的作用 :::tip 规范了页面中哪些元素能够使用定义好的样式 选择器就是一个条件，符合这个条件的元素，可以应用这个样式 ::: 选择器详解 通用选择器 *{样式声明} * { margin: 0; padding: 0 } /* 所有元素内外边距清0 */ /* 如果取值为0，可以省略单位 */ 元素选择器，标签选择器 div { color: red; } :::tip 页面中所有对应元素，都应用这个样式 设置页面中某种元素的默认样式ex:p {} img {} span {} 特殊用法：body{margin:0;padding:0;} body以及body内的元素，都会内外边距清0 ::: id 选择器，专属定制 只对当前页面，一个元素生效#id值{} :::tip 总结：一般id选择器在项目中很少单独使用，通常会作为子代选择器和后代选择器一部分。 ::: 类选择器 :::tip 定义页面上某个或者某类元素的样式 是一个公共样式，谁想使用，就用class调用一下 声明类选择器 .类名{样式声明} 类名的特点 必须有点 类名不能以数字开头 只能使用- _两种符号 引用类名 引用时，没有点 ::: 特殊用法 :::tip 多类选择器 一个元素引用多个类选择器 ::: 分类选择器 :::tip 更精准的确定使用这个样式元素 增加了选择器的权值？？？坑 ::: 类名1.类名2{}匹配同时引用类名1，和类名2的元素 /* Lorem */ .font36.text-danger { font-style: italic; } 元素名.类名{} h4.font36 { background-color: red; } /* Lorem amet. */ 匹配引用了font36这个类的h4元素 群组选择器 将多个选择器放在一起，定义公共样式（选择器之间使用,连接）选择器1，选择器2，选择器3........{样式声明} 后代选择器 通过元素的后代关系匹配元素后代关系：一级嵌套或者多级嵌套语法: 选择器1 选择器2 选择器3....{样式声明} 子代选择器 子代关系：就是一级嵌套关系语法：选择器1>选择器2>....{样式声明}子代选择器和后代选择器可以混写 div > p span { background-color: purple; } 伪类选择器 :::tip 匹配元素不同状态的选择器 伪类选择器，都是以:开头 匹配未访问的链接 选择器:link{样式声明} 匹配访问后的链接 选择器:visited{样式声明} 鼠标悬停 选择器:hover{样式声明} 元素激活状态，鼠标按住元素不抬起 选择器:active{样式声明} :focus 匹配获取焦点元素状态 ::: :::details 伪类示例 .text-danger{color:red;} p.text-danger{background-color:yellow;} div,#d2,p{color:green;} #d1{background-color:red;} #d2{background-color:blue;} #d3{background-color:purple;} #content li a{color:red;} /* div p span{background-color:red;}*/ /* div>p>span{background-color:orange;} */ div>span{background-color:yellow;} div>p span{background-color:purple;} div>span{background-color:red;} div>p>span{background-color:yellow;} div>p span span{background-color:blue;} /*a的未点击状态*/ a:link{color:red;} /*a访问后的状态*/ a:visited{color:yellow;} /*鼠标悬停时的状态*/ a:hover{color:blue;} /*激活状态*/ a:active{color:purple;font-size:40px;} 伪类选择器 新浪 11111 22222 33333 这是div中的span 这是div中的p 这是div中的p中span 小香香 TF口红 五菱宏光 GTR 粉色大G 1111 2222 3333 lorem lorem lorem Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet. img{width:200px;height:200px;} img:hover{width:200px;height:20px;} /*17：05~17：20休息*/ input:focus{background-color:yellow;} ::: 选择器的权值问题 选择器默认自带权值，权值越高，优先级越高 !important >1000 内联样式 =1000 id选择器 =100 class和伪类 =10 元素选择器 =1 *通用选择器 =0 继承的样式 无权值 ::: details 权值计算示例 #d1 .c2 span{color:yellow;} .c1 #d2 span{color:blue;} div .c2 #d3{color:red;} div,p,#d1,#d2,span,.c1,.c2{color:red;} div>div>div>div>div>div>div>div>div>div>div{color:red;}/*9*/ .c4{color:purple;}/*10*/ 1111111 权值的计算 ::: :::tip 权值的总结 当一个选择器中含有多个选择器时，需要将所有的选择器权值进行相加，然后比较，权值大的优先显示 权值相同，就近原则 群组选择的权值，单独计算，不能相加 样式后面添加!important，直接获取最高优先级 内联样式不能添加!important 选择器权值的计算，不会超过自己的最大数量级 100个元素(1)选择器相加，不会大于10 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/CSS/Dimensions-and-borders.html":{"url":"web/CSS/Dimensions-and-borders.html","title":"尺寸和边框","keywords":"","body":"尺寸和边框 尺寸属性 作用 设置元素的宽度和高度 属性 width: /* 宽度 */ max-width: /* 最大宽度 */ min-width: /* 最小宽度 */ height：/* 高度 */ max-height: min-height /* 取值：px为单位的数字和父元素的%比 */ :::warning 注意，如果不写宽高，各个元素默认的宽高是多少？ 块级元素不写宽，默认宽度占满父容器宽度100% 块级元素不写高，默认高度靠内容撑起来 行内元素，设置宽高无效。它的宽高靠内容撑起。 自带宽高属性的元素，设置宽高有效（img,table） ::: 附加知识点1.单位 单位： px 像素 in 英寸 1in=2.54cm pt 磅值 1pt=1/72in 多用于设置字体大小 cm 厘米 mm 毫米 项目中，为了页面可以在pc pad phone都正常显示 我们一般会使用相对单位 em 以父元素的数值当做基本单位 rem 以html的数值当做基本单位 % 溢出处理 当内容较大，元素区域较小的时候，就会发生溢出效果默认是纵向溢出 overflow: 取值：visible 默认值，溢出部分可见的 hidden 溢出部分隐藏 scroll 不管是否溢出，x和y轴方向都添加滚动条 auto 只有溢出才有滚动条，不溢出没有 overflow-x 设置水平轴滚动条 overflow-y 设置垂直轴滚动条 如何设置成横向溢出内部容器，设置宽度，大于外部容器的宽度 附加知识点，颜色合法值 :::tip 颜色的英文单词 red #rrggbb 6位16进制的数字 代表rgb 每一位0~ff 0~255 #aabbcc--->#abc #ff0000--->#f00 常用颜色 #f00 #0f0 #00f #ff0 #0ff #f0f #ddd #666 #333 #e8e8e8 rgb(r,g,b) 十进制 r,g,b 0~255 rgba(r,g,b,alpha) alpha0~1 hsl 不记 ::: 边框 边框的简写方式 border: width style color; border: 2px solid red; style： solid 实线 dotted 点点虚线 dashed 断线虚线 double 双实线 color：合法的颜色值和transparent[等同于全透明] 最简方式 border:style; 边框的单属性定义 border-color: border-style: 只要写了style属性，就会显示边框 border-width: 单边定义 border-top: width style color; border-right border-bottom border-left 单边的单属性定义 border-*-color border-*-width border-*-style *:top/right/bottom/left 边框的倒角(圆角) border-radius: /* 取值：以px为单位的数字 */ /* % 50%是一个圆形 */ /* 单角设置 */ border-top-left-radius: border-top-right-radius: border-bottom-left-radius: border-bottom-right-radius: 边框的阴影 box-shadow: 取值：h-shadow v-shadow blur spread color inset; h-shadow 水平方向的阴影偏移 v-shadow 垂直方向的阴影偏移 blur 阴影模糊距离 spread 阴影尺寸 color 阴影的颜色 inset/outset 设置内部阴影和外部阴影 轮廓 在边框外围的一圈线条，被称为边框的边框 outline:width style color; 去除轮廓，去除边框 border:none/0; outline:none/0; 框模型，盒子模型 元素在页面上实际占地空间的一种计算方式 :::tip 浏览器默认元素实际占地宽度= 左外边距+左边框+左内边距+内容区域宽度+右内边距+右边框+右外边距 浏览器默认元素实际占地高度= 上外边距+上边框+上内边距+内容区域高度+下内边距+下边框+下外边距 ::: 外边距margin：边框以外的距离，元素与元素之间的距离内边距padding：边框与内容区域之间的距离 外边距margin /* margin:v1;设置上右下左4个方向外边距 */ /* 改变margin，元素有位移效果。 */ /* 在页面元素做位置微调的时候，使用margin */ /* 设置单方向外边距 */ margin-top:10px; margin-right:20px; margin-bottom:30px; margin-left:40px; 取值: :::tip 以px为单位的数字 % 是父元素宽度的% 值取负数， margin-top + ↓ - ↑ margin-left + → - ← auto：对上下外边距无效 自动计算块级元素的左右外边距 让块级元素水平居中，（只对设置了宽度的块级元素生效） ::: 简写方式 margin:v1; /* 设置4个方向 */ margin:v1 v2; /* v1设置上下 v2设置左右 */ margin:0 auto;/margin:auto; margin:10px auto; margin:v1 v2 v3; 上 左右 下 margin:v1 v2 v3 v4; 上右下左 外边距的合并 :::tip 两个垂直外边距相遇时，他们将合并成一个 值以大的为准。 解决方法：布局设计的时候，直接规避 ::: 外边距溢出 在特殊情况下，为子元素设置上外边距，会作用到父元素上！ :::tip 特殊情况 父元素没有上边框 子元素的内容区域的上边沿与父元素的内容区域的上沿重合 解决方案： 给父元素添加上边框 弊端：影响了父元素的实际占地高度 给父元素添加上内边距 弊端：影响了父元素的实际占地高度 在子元素之间添加一个空的 ::: 关于块级元素，行内元素，行内块的总结(必须特别熟悉) 行内元素的特点 :::tip 设置宽高无效，宽高根据内容自动撑开 上下外边距无效，左右外边距有效 可以与其它行内元素和行内块元素共用一行 一行放不下，再折行 ::: 块级元素的特点 :::tip 设置宽高有效，如果不设置宽，宽度是父级宽度的100% 如果不设置高度，高度靠内容撑开 4个方向外边距都有效，独占一行 ::: 行内块元素 input :::tip 设置宽高有效，但是自带一个默认的宽高 4个外边距都有效，但是同一行修改一个行内块的垂直外边距，整行都会跟着一起发生位置改变。 可以与其他行内块和行内元素共用一行 ::: 自带外边距的元素 h1~h6 p body ol ul dl pre 由于不同浏览器对默认的外边距的解析可能会有差别所以在写代码之前，一般会把内外边距清空。这个行为叫做css reset * { margin: 0; padding: 0; } 内边距 padding 改变padding，感觉上是改变了元素的大小改变padding是不会影响 其它元素的，只会改变当前元素自己的实际占地尺寸 padding:v1; /* 设置4个方向内边距 */ padding:v1 v2; /* 上下 左右 */ padding:v1 v2 v3; /* 上 左右 下 */ padding:v1 v2 v3 v4; /* 上右下左 */ padding-top: padding-right: padding-bottom padding-left /* 取值：以px为单位的数字 */ /* % */ /* padding没有auto */ Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/CSS/box-sizing.html":{"url":"web/CSS/box-sizing.html","title":"盒子模型","keywords":"","body":"盒子模型 box-sizing :::tip 定义盒子模型的计算方式 box-sizing:content-box; 默认值,我们定义的width/height是内容区域 元素占地宽度=左外边距+左边框+左内边距+内容区域宽度+右内边距+右边框+右外边距 box-sizing:border-box;我们定义的width/height，是指border包含部分的宽高(含border) 元素占地宽度=左外边距+width+右外边距 ::: border-box使用的时机，一个容器内，在一行显示多个元素，如果子元素的width使用%定义，那么基本就要使用border-box了 背景 背景颜色 background-color: 合法颜色值 背景图片 background-image: url(09.png); 背景图片的平铺 background-repeat: 取值： 1.repeat 默认值 平铺 2.no-repeat 不平铺 3.repeat-x 水平方向平铺 4.repeat-y 垂直方向平铺 背景图片的定位 background-position:x y; 取值： 1.px为单位的数字 2.% 3.关键字 x:left/center/right y:top/center/bottom 背景图片的尺寸 background-size:x y 取值 取两个值，是分别设置宽高 取一个值，是设置宽，让高自适应 1. 以px为单位的数字 2. % 3. cover 覆盖，要求容器被全部填满，图片显示不全没关系 4. contain 包含。让容器可以完成的包含整张图片。图片必须完整， 容器是不是有空白区域，没关系 背景图片的固定 background-attachment 取值： scroll 默认值，背景图会跟随页面滚动条而滚动 fixed 固定，背景图相对于页面位置固定 不会跟随页面滚动条滚动 但是只会在原容器区域显示 简写方式 background: 取值： color image repeat attachment position; 最精简方式 background:color/image; 渐变 gradient 渐变是指多种颜色，平缓变化的一种显示效果渐变的主要因素色标，一种颜色，和他出现的位置一个渐变，最少两个色标 渐变分类 :::tip 线性渐变，以直线的方式来填充渐变色 径向渐变，以圆形的方式来填充渐变色 重复渐变，将线性，径向渐变重复几次实现 ::: 线性渐变 background-image:linear-gradient(方向 , 色标1，色标2.....) 方向angle：取值 1.关键字 to bottom to right to left to top 2.角度值 0deg to top 90deg to right 180deg to bottom 270deg to left 色标color-point:取值 颜色+位置 1.只写颜色不写位置，一般用于只有两个色标，对应开头和结尾 linear-gradient(0deg,#000,#0ff) 2.颜色+px为单位的数字 linear-gradient(0deg,#000 0px,#ff0 50px, #000 100px,#0ff 150px,#000 200px) 3.颜色+% background-image:linear-gradient(0deg,#000 0%, #ff0 25%,#000 50%,#0ff 75%,#000 100%); 径向渐变 background-image:radial-gradient(半径 at 圆心,色标1,色标2.....) 半径取值 px为单位的数字 圆心取值 ： 1.以px为单位数字 x y 2.x% y% 3.关键字 x: left/center/right y:top/center/bottom 色标取值 ，1.颜色+px 颜色的填充，就与半径没有关系了 2.颜色+% 这里的位置，是半径的% 重复渐变 重复的线性渐变background-image:repeating-linear-gradient(45deg,#000 0px,#ff0 10px,#000 20px,#0ff 30px,#000 40px); 浏览器兼容性问题(ie8.0以下不兼容) 为了兼容低版本浏览器，写的css代码，叫做css hack渐变属性，兼容低版本浏览器的写法 添加前缀 chrome/safari -webkit- firefox -moz- IE -ms- opera -o- 线性渐变的方向，发生了改变 top/ right/ bottom/ left background:-webkit-linear-gradient( bottom,#f00,#00f); background:-ms-linear-gradient( bottom,#f00,#00f); background:-o-linear-gradient( bottom,#f00,#00f); background:-moz-linear-gradient( bottom,#f00,#00f); 文本格式化 重点 字体大小 font-size: 取值： px/pt/em/rem为单位的数字 设置字体系列 font-family 取值： pc中字体库里有的字体，如果字体名称代空格，必须加\"\" 多个字体名称，使用,隔开 font-family:chiller,华文彩云,\"mv boli\"; 字体权重(加粗) font-weight 取值 1.关键字 lighter normal bold bolder 2.无单位，100的整倍数，最大值1000 字体样式 font-style:italic; normal 小型大写字母 font-variant:small-caps; 简写模式 font: style variant weight size family; /* 最简写法 font:size family */ 写css的思路 :::tip 从上往下写，从左往右写，从外往里写 找到目标元素，写样式步骤 尺寸，大体位置 边框，背景 文字相关 微调 (margin padding) ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/CSS/text.html":{"url":"web/CSS/text.html","title":"文本格式化","keywords":"","body":"文本格式化 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/CSS3/":{"url":"web/CSS3/","title":"CSS3","keywords":"","body":"CSS3 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 21:38:13 "},"web/JavaScript/":{"url":"web/JavaScript/","title":"JavaScript 基础","keywords":"","body":"JavaScript 基础 学习一门编程语言的基本步骤 了解背景知识：历史、现状、特点、应用场景 搭建开发环境：编写hello world 常量和变量 数据类型 运算符 逻辑结构 通用小程序 函数和对象 第三方框架、库 实用的项目 程序员必做50题 《JavaScript高级程序设计》第3版 JS 概述 历史 :::tip 1995年，JS最早出现在Netscape浏览器中，作为一种脚本语言。1997年，JS提交给了ECMA，制定统一的标准ECMAScript2009年，遵循CommonJS规范，开始向服务器端发展 ::: 现状 :::tip 既可以运行在客户端浏览器，也可以运行在服务器端 ::: 特点 :::tip 解释型语言，编译一行执行一行跨平台，支持所有的操作系统弱类型语言基于对象 ::: 应用场景 :::tip 制作浏览器端的交互效果创建web服务器、操作数据库等服务器端操作 ::: 谷歌 火狐 IE safari 欧朋 JS的开发环境 浏览器自带的JS解释器 服务器端的 NodeJS nodejs下载地址 node -v # 查看当前安装的nodejs版本号 执行JS代码 浏览器 // 创建01.js和01.html两个文件 // 在01.html中引入01.js文件 NodeJS node C:/xampp/..../01.js # 回车 JS语法规范 区分大小写 每行代码结束的分号可加可不加，建议都加 分为单行注释(//...)和多行注释(/.../) 变量 用于存储数据的容器 x = 1 y = 2 声明变量 var x = 1; // 使用var关键字声明了一个变量，名称叫x，存储的值是1 命名规则 :::tip 变量的名称可以使用字母、数字、美元符号($)、下划线(_)，不能以数字开头关键字和保留字不能作为变量名 ::: 变量注意 :::danger 变量可以只声明未赋值，var a; 此时的a值为 undefined可以为变量多次赋值，赋不同类型的值 ::: 一次性声明多个变量 var c = 5, d = 7, e; // 多个变量之间用逗号隔开 常量 const pi = 3.14; // 一旦声明不能再重新赋值 课后任务 :::details 课后任务 复习今天内容，整理思维导图 练习 使用变量保存圆的半径，常量保存圆周率，计算圆的周长和面积。 声明多组变量保存商品的单价和数量，计算商品的总价 预习js中的数据类型 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/JavaScript/typeof-data.html":{"url":"web/JavaScript/typeof-data.html","title":"数据类型","keywords":"","body":"数据类型 数据分为原始类型和引用类型 原始类型分为 数值型、字符串型、布尔型、未定义型、空 数值型 分为整型和浮点型 整型在内存中占4个字节，浮点型占8个字节 八进制 以0开头 十六进制 以0X开头，a~f 代表10~15 不区分大小写 0XFF 255 浮点型分为定点小数和指数型小数 3140 3.14e3 指数 -0.314 3.14e-1 3.14 :::danger typeof 检测数据类型 ::: 字符串型 数据被引号所包含就是字符串型，不区分单双引号 // 查看任意一个字符的Unicode码 '然'.charCodeAt() //28982 布尔型 true/false // 在程序中表示真或者假 // 用于一些比较的结果，还有一些是否的结果，例如是否登录，是否注册，是否在售... 未定义型 声明了变量未赋值，结果就是 undefined 空——null 只有一个值null，将来会和引用类型一起使用 数据类型转换 隐式转换 在运算的过程中，自动的发生转换 // 数字+字符串 数字被转成字符串 2 + '3' //'23' 数字+布尔型 布尔型转成数字 true->1 false->0 3 + true //4 3 + false //3 布尔型+字符串 布尔型转成字符串 '5' + true //'5true' JS中加号(+)的作用 执行加法运算执行字符串间的拼接 减法(-)、乘法(*)、除法(/)隐式转换 将运算符两端的数据转为数值型，如果转换失败，返回NaN(Not a Number)，不是一个数字，任何值和NaN执行加减乘除都会返回NaN；自动调用了Number转换成数值型。 ::: details 练习：查看以下程序的运行结果 var num1 = 3, num2 = true, num3 = 'tedu'; console.log(num1 + num2 + num3); //'4tedu' console.log(num2 + num3 + num1); 'truetedu3' console.log(num3 + num1 + num2); 'tedu3true' ::: 强制转换 强制转为数值型 Number() Number('2') //2 Number(true) //1 Number('2a') //NaN Number(undefined) //NaN Number(null) //0 强制转换为整型 parseInt() // 常用于将字符串或者数字转为整型，其它的数据返回NaN，如果要转换的字符串开头是非数字，则返回NaN var a = \"1\"; console.log(parseInt(a)) 强制转为浮点型 parseFloat() // 和parseInt的用法基本一致，只是转换为浮点型数据 // '2.5a' 'a2.5' parseFloat(\"2.5a\") // 2.5 parseFloat(\"a2.5\") // NaN 强制将数值型和布尔型转为字符串型 toString() var num=10; num.toString(); // '10' 运算符 表达式：由运算符连接的操作数据，所组成的形式。 运算符分为算术运算符、比较运算符、逻辑运算符、位运算符、赋值运算符、三目运算符 算术运算符 // + - * / % ++ -- // % 取余 // ++ 自增，在原来的基础之上加1 // -- 自减，在原来的基础之上减1 console.log(a++); // 先打印a的值，然后执行自增 console.log(++a); // 先执行自增，然后打印a的值 ::: details 练习 var num = 3; console.log( num-- + --num ); ::: 比较运算符 /* > = '10') // 字符串转为数值 '10'->10 console.log('3' > '10') // 两个字符串比较的是首个字符的Unicode码 console.log(3 > '10a') // false console.log(3 = 逻辑运算符 && 并且 关联的两个条件都满足，结果是 true，否则 false || 或者 关联的两个条件满足其一，结果是 true，否则 false ! 非 取反向 !true-> false !false -> true :::danger 注意事项：逻辑短路无需关注整个逻辑运算的结果是true还是false，重点是看是否会执行第二个条件 ::: ::: details 练习：以下程序是否会保错 var num = 3; num > 5 && console.log(a); num 练习：声明变量保存年龄，如果满18岁，打印'成年人' ::: 位运算符 位运算(了解) 在执行运算的时候，计算机会把数据转成二进制进行运算 1 10 11 100 101 110 111 1000 1001 1010 2 4 8 100101=100000+100+1 32 + 4 + 1 = 37 1010110 = 1000000 + 10000 + 100 + 10 64 + 16 + 4 + 2=86 25 = 16 + 8 + 1 10000 + 1000 + 1 = 11001 按位与(&) 上下两位都是1，结果是1，否则是0 按位或(|) 上下两位含有1，结果是1，否则是0 按位异或(^) 上下两位不同为1，相同为0 按位右移(>>) 删除二进制的最后一位 按位左移(赋值运算符 = += -= *= /= %= 三目运算符 一目 一个运算符连接一个数据 -- ++ ! 二目 一个运算符连接两个数据 + - * / ... 三目 两个运算符连接三个数据 条件表达式 ? 表达式1 : 表达式2 如果条件表达式为 true ，执行表达式1 如果条件表达式为 false ，执行表达式2 练习：声明两个变量保存用户名和密码，如果用户名为root，并且密码为123456，打印登陆成功，否则打印登陆失败 课后任务 ::: details 练习 声明变量保存一个年份，判断这个年份是否为闰年，结合逻辑短路，如果是闰年，打印闰年闰年：标准 ? 4 年一闰，100 不闰，400 再闰预习js中的流程控制 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/JavaScript/process-control.html":{"url":"web/JavaScript/process-control.html","title":"流程控制","keywords":"","body":"流程控制 浏览器端函数 alert() 弹出警示(消息)框 prompt() 弹出提示(输入)框，需要使用变量来保存输入的值，类型默认是字符串类型，如果输 入框中内容为空，返回空字符('')，如果点击取消返回 null 练习：两次弹出提示框，输入数字，计算两个数字相加，打印结果。 程序 = 数据 + 算法 程序分为顺序执行、选择执行、循环执行 流程控制——选择执行 if语句 if(条件表达式){ // 语句1; } // 语句2 if 后的大括号中如果只有一行语句，则可以省略大括号 if-else语句 if(条件表达式){ // 语句1; }else{ // 语句2; } // 在条件表达式中，有一些值默认代表false // 0 NaN '' undefined null 练习：弹出两次提示框，分别输入商品的单价和数量，获取总价，如果总价满1000打九折；假如卡内余额800，如果余额大于等于商品总额，警示框弹出'pay success'，否则警示框弹出'pay error' if-else嵌套 if(条件表达式1){ // 语句1 }else ... if(条件表达式n){ // 语句n; }else{ // 语句n+1; // 以上所有的条件表达式都为false } switch-case 是一种特殊的多项分支语句 switch(表达式){ //通常是一个变量 case 值1: //如果表达式的值为 值1 // 语句1; break; ... default: // 语句n+1; //如果表达式的值和case中的每个值比较都是false } // 表达式在和case后的值比较的时候，使用的是全等于，要求值和类型都相同 对比if-else嵌套和switch-case的区别 :::tip 相同点：两者都可以用于多项分支语句不同点：if-else可以判断相等或者不等的情况，使用范围更广泛；switch-case只能用于全等于的比较，结构上更为清晰合理，执行效率更高。 ::: 循环 循环：就是一遍又一遍执行相同或者相似的代码 循环的两个要素:::tip 循环的条件：循环的次数循环体：重复执行的相同或者相似代码 ::: while循环 while(循环条件){ // 循环体 } break 在循环中，可以提前结束任何形式的循环 ::: details 练习 声明变量保存任意一个数字，无限循环弹出提示框，并输入数字，如果输入的数字大于保存的数字，弹出警示框提示'big'，如果输入的数字小于保存的数字，弹出警示框提示'small'，否则弹出警示框提示'right'，结束循环。 ::: isNaN() 判断一个值是否为NaN 是->true 不是->false do-while 循环 do{ // 循环体 }while(循环条件); // 先执行一遍循环体，然后再判断循环条件，即使循环条件为false，也会执行一遍循环体。 ::: details 练习 声明变量保存123456，循环弹出提示框输入密码，如果输入正确结束循环。 ::: for循环 for(表达式1; 表达式2; 表达式3){ // 循环体 } // 表达式1：初始值 // 表达式2：循环条件 // 表达式3：增量 break 和 continue break: // 结束循环，后续不会再执行后续的循环 continue: // 跳过后边的循环体，继续执行增量，也就是下一次循环 ::: details 练习 计算1~100之间所有偶数的和，如果遇到奇数跳过 ::: 循环嵌套 任何的循环之间可以相互嵌套 for(var i = 0 ; i \"); } 课后任务 ::: details 练习 打印本世纪(2000~2100)前10个闰年 计算1~100之间所有整数的和，当和大于4000的时候，提前结束循环，并打印当前的和 打印九九乘法表 预习JS中的函数，作用域 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/JavaScript/function.html":{"url":"web/JavaScript/function.html","title":"函数对象","keywords":"","body":"函数对象 函数 isNaN(数据)/parseInt/parseFloat/Number/prompt... 函数分为系统函数和自定义函数 function: 功能体，函数(方法)，可以接受若干个数据，返回处理的结果。用于封装反复执行的代码——饺子机 创建普通函数 function 函数名称() { // 函数体 //要封装的代码 } // 调用 函数名称() ::: details 练习 创建函数，封装两个数字相加的和，调用多次。 创建函数，封装两个数字相加的和，调用多次。 ::: 创建带有参数的函数 function 函数名称(参数列表) { // 用于接收传递的数据 // 函数体; } // 调用 函数名称(参数列表) // 实际传递的数据 // 参数: 创建函数时的参数称为形参，调用时参数称为实参，实参会赋值给形参，多个参数之间用逗号隔开。参数可以有0个或者多个，如果形参未被赋值，值为undefined ::: details 练习 创建函数，封装计算1~任意数字之间所有整数的和，调用多次。 创建函数，封装计算任意两个年份之间的闰年个数，调用多次。 ::: 创建带有返回值的函数 function 函数名称(参数列表){ // 函数体; return 值; // 返回值，函数执行完返回的结果 } // 调用 函数名称(参数列表) ::: danger 注意事项:如果函数中没有return，或者return中没有加任何值，返回undefined；执行完return后的代码不会再执行 ::: ::: details 练习 创建函数，传递两个参数，返回任意两个数字的最大值。 创建函数，传递三个参数，返回任意三个数字的最大值 创建函数，传递订单的状态码，返回对应的汉字状态 1-待付款 2-待发货 3-运输中 4-已签收 5-已取消 其它-无法追踪 创建函数，传递任意一个年份，返回是否为闰年 是->true 不是->false 创建函数，传递任意一个年份，如果是闰年返回366，否则返回365 计算1~任意数字之间所有整数阶乘的和 计算任意数字的阶乘。 n~1之间所有整数的乘积1 + 2 + 3 + 4 + 5 4! = 4 * 3 * 2 * 1 5! = 5 * 4 * 3 * 2 * 1 ::: 对比 break 和 return 用法 :::tip break用于结束switch语句，还可以用于提前结束循环。return 用于函数中返回值，可以结束函数后续代码执行。 ::: 作用域 变量或者函数的可访问范围，分为两种 :::tip 全局作用域：在全局使用var声明的变量，可以在任意范围访问到函数作用域：在函数使用var声明的变量，只能在函数内部访问到 ::: :::warning 注意事项：在函数内不使用var声明的变量，是全局变量，可以在函数外部访问——不推荐这样写。 ::: 变量提升 JS程序执行前，会将使用var关键字声明的变量提升到所在作用域的最前边，但是赋值还是在原来的位置。 函数的作用域 函数的可访问范围，在全局作用域下创建的函数可以在任意位置访问；在函数作用域下创建的函数只能在函数内部访问。 函数提升 和变量提升一样，JS程序执行前，会把function关键字创建的函数提升到所在作用域的最前边，在调用的时候才会执行函数体中的代码 递归 在函数的内部调用自身，默认是一个无限循环。 使用：要有跳出条件，结合者return使用 // 斐波那契数列 function box(m) { if (m == 1 || m == 2) { return 1; } return box(m-1)+box(m-2); // 除去1和2的两种情况，递归斐波那契数列一行代码就能搞定，但是递归性能是大大不如函数的。 } ::: details 练习 使用递归计算1~任意数字之间所有整数的和 ::: 匿名函数 // 没有名称的函数 匿名函数自调用 // 目的：创建函数作用域包裹起来，防止污染全局 (function(形参列表){ // 函数体中的变量和函数不能被外部访问 })(实参列表); // 创建函数 // 函数声明 function fn1(){ } // 函数表达式 var fn2=function(参数){ // 函数体; } // 变量名就是函数的名称 对比函数声明和函数表达式的区别 函数声明创建函数存在提升，可以在任意位置创建；函数表达式使用变量创建的，只是存在变量提升，不存在函数提升，只能先创建，再调用。 ::: details 练习 使用函数表达式创建函数，计算任意两个数字之间所有整数的和 ::: 回调函数 把匿名函数以实参的形式传递，意味着形参就是传递的匿名的函数名称 function fn(a){ //调用fn的时候，匿名函数赋值给参数a，a就是函数名称 a() //执行传递的匿名函数函数体中的代码 } ::: details 练习 创建函数，传递两个参数，实参使用匿名函数的形式传递，在匿名函数的函数体中添加若干行代码；在函数中执行匿名函数体中的代码。 ::: 全局函数 parseInt()/parseFloat()/isNaN() encodeURI() // 对网址中的汉字进行编码 decodeURI() // 对已经编码网址进行解码 isFinite() // 判断一个值是否为有限值 // 是->true 不是-false 2/0 ->Infinity(无穷) 0/2 ->0 eval() // 执行字符串中的表达式 eval('1+2') //3 对象 属于引用类型数据 对象：是一组属性(property)和方法(method)的集合 一台电脑: 属性有颜色、尺寸、品牌、内存大小...方法有看视频、上网、敲代码.. 一辆汽车: 属性有颜色、长度、品牌、空间大小...方法有代步，拉货、撞人... 万物皆对象 JS中的对象 内置对象: JS提供的宿主对象: 根据不同的执行环境划分自定义对象: 自己创建的对象 创建自定义对象 对象字面量内置构造函数自定义构造函数 对象字面量创建对象 使用大括号创建空对象属性名和属性值之间用冒号隔开多组属性之间用逗号隔开属性名中的引号可加可不加，如果含有特殊字符必须加 var phone = { color: '黑色', brand: '华为', no: 'P30', size: 5.9 } ::: details 练习 创建一个员工对象，包含编号，姓名，工资，生日 创建一个手机对象，包含颜色，尺寸，品牌 ::: 访问对象中的属性 对象.属性名 对象['属性名'] // 如果访问的属性名不存在，返回undefined var phone = { color: '黑色', brand: '华为', no: 'P30', size: 5.9 } console.log(phone.color) console.log(phone['color']) ::: details 练习 创建图书的对象，包含编号、标题、作者、价格，修改图书的价格，打印图书的作者，添加图书的出版社。 ::: 内置构造函数创建对象 new Object() // 创建一个空对象 // 需要单独为对象添加每一个属性 //使用内置构造函数创建对象 var car = new Object(); //添加属性 car.brand = '五菱宏光'; car.color = '白色'; car['price'] = 60000; ::: details 练习 创建一个笔记本对象，包含编号，标题，价格，规格 ::: 遍历对象中的属性 访问对象中的每一个属性 for(var key in 对象){ // key 代表对象中的每个属性名 // 对象[key] 通过属性名或者对应属性值 } // 练习：创建对象，包含有若干个成绩，遍历对象属性，计算总成绩 var score={ chinese: 87, math: 95, english: 99, sport: 89 }; var sum = 0; for(var key in score){ // console.log(key,score[key]); // 把每一个成绩加到 sum 中 sum += score[key] } console.log(sum); ::: details 练习 创建对象，包含有若干个成绩，遍历对象属性，计算总成绩 ::: 课后任务 ::: details 练习 创建对象，包含若干个年龄，获取平均年龄，把年龄大于20岁的打印出来。 预习js中的数组 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/JavaScript/array.html":{"url":"web/JavaScript/array.html","title":"数组","keywords":"","body":"数组 判断对象中是否含有某个属性 对象.属性名 === undefined true-> 不存在 false-> 存在 对象.hasOwnPropery('属性名') true-> 存在 false-> 不存在 '属性名' in 对象 true-> 存在 false -> 不存在 // 练习 var obj = { name: '张三', age: 18 }; obj.hasOwnProperty('name'); // --> true obj.hasOwnProperty('id'); // --> false 对象中的方法 var person={ ename: 'tom', say: function(){ // 访问当前对象的属性名，this指代当前所在的对象 this.ename } } // 调用对象中的方法 person.say() ::: details 练习 创建一个圆对象，添加属性半径和圆周率，添加计算周长和面积两个方法，返回计算的结果。最后调用 ::: 数组 是有多个元素组成的集合，每个元素就是一个数据 创建数组 常规方式 // 创建数组并给数组元素赋值 var array = new Array(); array[0] = \"Aftersoil\"; array[1] = \"wiki\"; array[2] = \"Sitio\"; 数组字面量// 字面-隐式创建 var array = [\"Aftersoil\", \"wiki\", \"Sitio\"]; ::: details 练习 创建数组，包含有多个商品的名称; 创建数组，包含多个城市的名称 ::: // 访问数组中的元素 数组[下标] // 下标从 0 开始，不存在的元素返回 undefined 内置构造函数 ```js var array = new Array(\"Aftersoil\", \"wiki\", \"Sitio\"); // new Array(3) 初始化元素个数为3，可以添加更多个元素 ::: details 练习 - 创建数组，包含有若干个图书名称；创建数组，初始化长度为5，添加5个场上位置。 ::: - 创建数组并给数组元素赋值 ```js 数组.length // 获取数组中元素的个数 // 在数组的末尾添加元素 // 数组[ 数组.length ] = 值; ::: details 练习 创建一个空数组，使用数组长度添加多个国家名称 ::: 数组的分类 // 分为关联数组和索引数组 // 索引数组以0以上的整数作为下标 // 关联数组以字符串作为下标，只能单独的添加元素 遍历数组 for-in for(var key in 数组){ // key 下标 // 数组[key] 下标对应的元素 } // 既可以遍历关联数组，也可以遍历索引数组 var array = [\"Aftersoil\", \"wiki\", \"Sitio\"]; for(var key in array){ console.log(key) console.log(array[key]) } 循环 for(var i=0;i ::: details 练习 创建数组，包含有多个国家，把所有的'中国'改为'china' 创建数组，包含有多个国家，查询出中国出现的次数 创建数组，包含多个数字，获取数组中的最大值 创建函数getAvg，传递一个参数(数组)，返回平均值。 ::: 数组API(方法) // API 应用程序编程接口，预定义好的一些方法或者函数 // 将数组中的元素按逗号组合成字符串 toString() // 将数组中的元素按指定的字符组合成字符串，默认是逗号 join('-') //拼接多个数组 concat(arr1,arr2) // 截取数组中的元素，start开始的下标，end结束的下标，不包含end本身，如果是负数，表示倒数。end为空截取到最后。 slice(start,end) // 删除数组中的元素，start开始的下标，count删除的长度，value删除后补充的元素；count为空删除到最后，start为负数表示倒数；返回删除的元素，原数组会发生变化。 splice(start, count, value1,value2..) ::: details 练习 创建数组a~g组成，每个字符是一个元素；分别截取cd，f，b；把截取的结果拼接成一个新数组 创建数组a~h，每个字母是一个元素，删除de，替换f为m，在下标为1的位置插入字母z ::: 数组练习视频 视频 1 视频 2 视频 3 课后任务 ::: details 练习 使用遍历数组，实现翻转数组中元素 使用冒泡排序将数组中的元素从小到大排序 冒泡排序 预习字符串API ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/JavaScript/string-api.html":{"url":"web/JavaScript/string-api.html","title":"字符串 API","keywords":"","body":"字符串 API 数组 API 对数组元素排序，默认是按照Unicode码从小到大排序 sort(function(a, b){ return a-b; //按照数字从小到大排序 //return b-a; //按照数字从大到小排序 }); push() // 往数组的末尾添加元素，返回数组的长度 pop() // 删除数组末尾的元素，返回删除的元素 pop() // 删除数组末尾的元素，返回删除的元素 shift() // 删除数组开头的元素，返回删除的元素 ::: details 练习 创建数组，包含有多个员工数据(对象)，包含属性有编号、姓名、工资 ::: 二维数组 数组中的每个元素也是数组 var arr = [ [], [], [], ... ] // 访问二维数组中的元素 arr[下标][下标] 字符串 包装对象: 目的是让原始类型像引用类型一样，具有属性和方法。JS提供了3中包装对象: String、Number、Boolean 将任意数据转为字符串 new String(值) // 返回对象 使用和字符串没有区别 String(值) // 返回字符串 //包装成字符串对象 var str1 = new String(3); //console.log(str1, typeof str1); //console.log(str1 + 'b'); //将任意的数据转为字符串 var str2=String(true); //console.log(str2, typeof str2); var str3 = 'a'; 转义字符 转换字符的意义用法：放在要转换意义的字符前边 // \\' 将特殊意义的引号转成普通字符 // \\n 将字符n转换成换行符 // \\t 将字符t转换成制表符(tab键效果) //转义字符 \\ console.log('It\\'s a dog'); console.log('hello \\no world'); console.log('a\\tb'); console.log('welcome to chi\\\\na'); 字符串 API var str = 'javascript'; // 获取字符串的长度 length console.log( str.length ); console.log( str[0] ); // 获取下标对应的字符，也可以使用数组形式 字符串[下标] charAt() console.log( str.charAt(1) ); // 遍历字符串，获取每个字符 for(var i = 0; i ::: details 练习 声明变量保存字符串，判断该字符串是否为邮箱格式(@)，如果有打印'合法的邮箱'，否则打印'非法的邮箱' 声明变量保存4个英文字母，使用无限循环弹出提示框，输入验证码(不区分大小写)，如果输入正确，结束循环。 声明变量保存邮箱，分别截取用户名和服务器名称 声明变量保存省份证号，截取出生的年月日和性别，打印 '小然的生日为1980年11月11日 性别男' 截取字符串，start开始的下标，end结束的下标，如果end为空截取到最后，如果下标为负数自动转成0。 使用split获取邮箱的用户名和服务器名称 ::: 匹配模式(掌握) 作用：用于查找、替换字符串 var str='xiaoran产于上世纪七八十年代,Xiaoran至今性能依然强劲,xiaoran一顿饭能吃10盘羊肉,XIAORAN是一个美男子'; // indexOf console.log( str.search('XIAORAN') ); // 用于查找满足条件的第一个的下标，类似于indexOf，如果找不到返回-1 /xiaoran/i search(value) console.log( str.search(/XIAORAN/i) ); // 用于查找满足条件的字符串，返回一个数组 match(value) console.log( str.match(/XIAORAN/ig).length ); // 查找并替换，value1要查找的字符串，value2要替换的字符串 replace(value1,value2) console.log( str.replace(/xiaoran/gi,'***') ); // 忽略大小写 i->ignore // 全局查找 g->global Math对象 不需要创建，可以直接使用 PI // 取圆周率 abs() // 取绝对值 floor() // 向下取整 ceil() // 向上取整 round() // 四舍五入取整 max() // 取一组数字最大 min() // 取一组数字最小 pow() // 取 x 的 y 次幂 random() // 取随机数 >=0 =0 课后任务 ::: details 练习 将一句英文每个单词的首字母大写，其余小写 随机产生 0~9 之间的一个整数 预习Date对象 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-31 08:36:29 "},"web/JavaScript/date.html":{"url":"web/JavaScript/date.html","title":"Date 对象","keywords":"","body":"Date 对象 用于对日期时间的存储和计算 创建Date对象 var d = new Date('2019/6/19 10:48:50') var d1 = new Date(2019,5,19,10,48,50) // 1月~12月范围 0~11 var d2 = new Date() // 存储当前的系统时间 var d3 = new Date(24*60*60*1000) // 存储距离计算机元年毫秒数 获取存储的日期时间 var d = new Date('2019/6/19 10:56:30'); //获取存储的日期时 console.log( d.getFullYear() ); console.log( d.getMonth()+1 );// 0~11 console.log( d.getDate() ); console.log( d.getHours() ); console.log( d.getMinutes() ); console.log( d.getSeconds() ); console.log( d.getMilliseconds() );// 毫秒 console.log( d.getDay() );// 0~6 星期日~星期六 console.log( d.getTime() );// 获取距离计算机元年毫米数 获取本地字符串格式 toLocaleString() // 2019-6-19 14:09:30 toLocaleDateString() // 2019-6-19 toLocaleTimeString() // 14:09:30 var d = new Date(); console.log( d.toLocaleString() ); console.log( d.toLocaleDateString() ); console.log( d.toLocaleTimeString() ); 修改日期时间 setFullYear / setMonth / setDate / setHours / setMinutes setSeconds / setMilliseconds / setTime // setTime使用后，所有的日期时间都有可能会被覆盖 var d1 = new Date('2019/6/19 15:20:30'); //修改年份 d1.setFullYear(2018); d1.setMonth(8);// 0~11 //三天后 // 获取当前的日期，再加3，替换原来的日期 d1.setDate( d1.getDate() + 3 ); console.log(d1) 复制(克隆)Date对象 var d1 = new Date(); var d2 = new Date(d1);// 克隆d1对象 Number 对象 // 将数据转为数值型，返回对象 new Number(值) // 将数据转为数值型，返回数值 Number(值) // 最大值 Number.MAX_VALUE // 最小值 Number.MIN_VALUE // 取小数点后n位 toFixed(n) // 将数值转为字符串，同时可以设置进制，n就是设置的进制，2 8 16... toString(n) var num1 = 2; var num2 = Number(true); //构造函数 var num3=new Number(null); console.log(num3,typeof num3); console.log(num3+2); console.log(Number.MAX_VALUE); // 最大值 console.log(Number.MIN_VALUE); // 最小值 var num4 = 2*3.14*5 var num4 = 0.1+0.2; var num5 = 2999; console.log(num5.toFixed(2)); // 取小数点后n位 var num6=13; // 0xd console.log( num6.toString(2) ); Boolean 对象 // 将数据转为布尔型，返回对象 new Boolean(值) // 将数据转为布尔型，返回布尔型 Boolean(值) // 转数据隐式转换为布尔型 !!值 var b1=true; //NaN 0 '' undefined null var b2 = Boolean(NaN); var b3 = Boolean([]); var b4 = new Boolean(3); var b5 =!![];// 隐式转换为布尔型 console.log(b5); console.log(b4, typeof b4); 错误处理 :::tip 语法错误(SyntaxError): 错误的使用了中文符号，缺少括号引用错误(ReferenceError): 使用了未声明的变量类型错误(TypeError): 错误的使用了小括号()范围错误(RangeError): 参数的使用超出了范围自定义错误 throw '自定义的错误信息'说明：第一种错误出现后，一行代码都不执行；其它的错误出现后，会影响后边代码的执行。 ::: 语法错误 // JS程序执行前，检查是否有语法错误 console.log(1); //语法错误 var a = 1； 引用错误 // 引用错误，使用未声明的变量 console.log(a); var b = 2; var person = { ename:'tom' } b(); // 类型错误,错误的时候使用了括号 person.ename(); 范围错误 var arr = new Array(-3); 自定义错误 var num = 'abc'; // 如果num不是数字，抛出自定义错误 // 先调用Number转数值 NaN if( isNaN(num) ){ // 判断是否为NaN not a number throw '请提供一个数字'; } 处理错误 try{ // 可能出现的错误（类型/引用/范围/自定义错误） }catch(err){ // 如果try中代码保错，才会执行这里边的代码 // 会把错误信息交给err // 不会再阻止代码往后执行 } // 处理错误 // 要求提供的数字5~10之间 var num = 7; // 尝试执行 try{ if(num > 10){ throw '太大了'; } }catch(err){ // 只有try中的代码报错，才会执行catch中的代码，错误信息交给err console.log(err + '：请输入一个5到10之间的数字'); } console.log(2); ::: details 练习 计算2019年6月21日距离国庆节还有?天?时?分?秒 ::: Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/Ajax/":{"url":"web/Ajax/","title":"Ajax","keywords":"","body":"Ajax URL https://wiki.aftersoil.xyz/index.html 结构：协议 + 主机名称 + 目录结构 + 文件名称 URL完整的结构 ://:@:/; ?# scheme 方案，协议。以哪种方式获取服务器资源 不区分大小写。常见的协议 http、https、ftp、file : 登陆这个服务器的用户名和密码 host 主机名称 127.0.0.1 ip地址 www.baidu.com 域名 表示你要访问的服务器，在网络上具体的门牌号码 port 端口号 在主机上，程序开启服务，会对应一个唯一的端口号 端口号理论最大值 0~65535 不要修改 0~1024 的端口 path 路径，结构目录，资源在服务器上存放的位置 params 参数，跟踪状态的参数 保存在session/cookie query get方法提交请求时，问号后面的查询字符串 # 锚点 HTTP协议 :::tip HyperText Transfer Protocol 超文本传输协议 规范了数据是如何打包和传递的(专门用于传递html文件) HTTP协议的历史，我们目前使用的版本 http/1.1::: web 请求原理 消息/报文 Message :::tip 请求消息Request Message(请求起始行，请求头，请求主体)响应消息Response Message(响应起始行，响应头，响应主体) ::: 请求消息Request Message :::tip 请求消息，客户端发送给服务器的数据块由三部分组成，请求起始行，请求头，请求主体 ::: 请求起始行 HTTP协议规定的请求的方法和Restful规则中的方法对比Restful API是一种规则，利用http的已有的4个方法定义了4个行为，使用这个4个行为发送请求 HTTP协议规定的请求的方法 Restful规则中的方法 get 明文传参，上限2kb，向服务器要数据的时候使用，无请求主体 get 查数据的时候 无请求主体 后台 req.query post 隐式传参,无大小限制，给服务器数据的时候使用，有请求主体 post 创建(增) 有请求主体 后台 req.body put 放置文件到服务器，一般会被禁用 put 修改，有请求主体 后台 req.body delete 把服务器上某个文件删除，一般会被禁用 delete 删除，无请求主体 后台 req.query 请求头 Host: www.tmooc.cn客户端告诉服务器。我要访问www.tmooc.cn这个主机。 Connection: keep-alive客户端告诉服务器，请开启持久链接 User-Agent:告诉服务器，我这个浏览器的类型和版本号 Accept-Encoding: gzip告诉服务器，我这个浏览器可以接收的压缩文件的格式 Accept-Language: zh-CN告诉服务器，我这个浏览器可以接收的自然语言的类型 Referer: http://www.tmooc.cn/告诉服务器，当前的请求，是来源于哪个页面 请求主体 formdataget/delete没有请求主体post/put有请求主体 响应消息Response Message 响应消息，服务器发送给客户端的数据块由三部分组成，响应起始行，响应头，响应主体 响应起始行 HTTP/1.1 200 OK 协议版本号 http/1.1 响应状态码 服务器告诉客户端，服务器的响应状态码是什么 1XX, 正在请求，提示信息 2XX, 200 响应成功 3XX, 301 永久重定向 302 临时重定向 304 请求未改变，命中缓存 4XX, 404 not found 请求资源不存在 403 权限不够 405 请求方法不被允许 5XX, 500服务器代码出错 原因短句，对响应状态码简短的说明 响应头 Date: Thu, 04 Jul 2019 07:48:02 GMT 格林威治时间告诉浏览器，服务器响应的时间 Connection: keep-alive服务器告诉浏览器，我已经打开了持久链接 Content-Type: text/html告诉浏览器，响应主体的类型是什么 text/html 响应回来的数据是html文本 text/css 响应回来的数据是css文本 application/javascript js文本 application/xml xml文本 application/json json 文本 image/jpg image/png image/gif 响应主体 服务器传递给浏览器的数据 总结 缓存 客户端将服务器响应回来的数据进行自动的保存当再次访问的时候，直接使用保存的数据 缓存的优点 :::tip 减少冗(rong)余的数据传输，节省了客户端的流量 节省服务器带宽 降低了对服务器资源的消耗和运行的要求 降低了由于远距离传输而造成的加载延迟 ::: 缓存原理，新鲜度和过期 :::tip 请求--无缓存--连接服务器--存缓存--客户端渲染 请求--有缓存--够新鲜--使用缓存--客户端渲染 请求--有缓存--不新鲜--连接服务器确认是否过期--没过期--更新缓存新鲜度--客户端渲染 请求--有缓存--不新鲜--连接服务器确认是否过期--过期--连接服务器--存缓存--客户端渲染 ::: 操作缓存，需要前端和后端都写代码 缓存相关的消息头Cache-Control: max-age=0 单位是s从服务器将文档传到客户端之时起此文档处于新鲜的秒数，是一个相对时间 修改请求消息头 HTTP 性能优化 HTTP 的连接过程发送请求-->建立连接-->服务器处理请求-->访问资源-->构建响应-->发送响应-->记录日志 http连接的性能优化 :::tip 减少连接创建的次数(开启持久连接) 减少请求的次数(代码设计更合理) 提高服务器端运行的速度 尽可能的减少响应数据的长度 ::: 安全的HTTP协议，HTTPS HTTPS，是安全版本的http协议S:SSL为数据通信提供安全支持 客户端发送请求--->ssl层加密--->服务器接收到加密文件--->SSL层解密，得到请求明文，对请求做处理 服务器发送响应--->SSL层加密---->客户端得到加密文件--->ssl层解密，得到响应明文，解析执行响应内容 DOM操作(简单DOM操作) ajax提交请求，不使用form表单但是form表单自带收集数据的功能如果不用form，就没有自动收集数据的功能了我们需要使用js 的dom操作，手写代码，收集数据 完整的JavaScript的组成 js核心代码：ECMA Script ES6 DOM Document object Model 文档对象模型就是为了能够操作html中元素的(内容，值，样式) BOM Browser object Model 浏览器对象模型让js能够动态操作浏览器 使用js的dom获取页面数据 找到元素对象 // 获取html的元素对象 var obj = document.getElementById(\"元素id\")； // document--->当前html文档的对象 获取/修改这个元素的值/内容 URL 视频 video { width: 100%; } Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 19:26:55 "},"web/Ajax/AJAX-XHR.html":{"url":"web/Ajax/AJAX-XHR.html","title":"AJAX XHR","keywords":"","body":"AJAX XHR 简单的dom操作 由于ajax不使用form 而form具有自动收集数据的功能。 不使用form，就需要使用dom手写代码收集数据 获得承载数据的元素对象 var obj = document.getElementById(\"uname \"); 通过这个元素对象获取/修改数据 // 1.input对象的数据，是使用value属性 obj.value = \"123\"; // 设置 var res = obj.value; // 获取 // 2.所有的双标签，使用innerHTML属性 获取/修改 数据 obj.innerHTML=\"123\"; // 设置 var res = obj.innerHTML; // 获取 ES6的简化 ES6提出，可以使用元素的id直接代表整个元素的对象所以，代码简化为如下 h.innerHTML = msg.value; innerHTML详解 使用innerHTML可以动态给双标签添加内容 这里的内容，指可以添加其他元素 事件 通过用户的行为来激发的操作，就是事件 onclick // 单击 onblur // 焦点移除事件，元素失去焦点，马上调用js onfocus // 获取焦点事件，元素获得焦点，马上调用js ajax 同步 Synchronous 在一个任务进行时，不能开启其他任务同步访问：浏览器在向服务器发送请求，只能等待服务器的响应，不能做其他事情 出现场合 [!Tip|style:flat] 地址栏输入url，访问页面 a标签的跳转 form提交 异步Asynchronous 在一个任务开启时，可以同时进行其他任务异步访问：浏览器向服务器发送请求时，用户还能在页面上做其他操作 出现场合 [!Tip|style:flat] 用户名注册的验证 百度的搜索建议 股票软件 什么是 Ajax Asynchronous JavaScript and xml 异步的 js 和 xml(数据承载方式)本质：使用js提供的异步对象XMLHttpRequest异步的向服务器提交请求并且接受服务器响应回来的数据 使用ajax 创建异步对象 创建请求 发送请求 接收响应数据 创建异步对象 var xhr = new XMLHttpRequest(); 创建请求 xhr.open(method, url, isAsyn); xhr.open(\"get\", \"http://127.0.0.1:8080/login\", true); // method: 请求的方法，注意必须是字符串的形式\"get\" \"post\" // url: 请求的url，注意必须是字符串 // isAsyn: 是不是要使用异步，boolean值，true/false 发送请求 xhr.send(formdata); // 注意，get方法，没有formdata请求主体 // 所以在使用get方法时，这里的参数可以不填写，也可以写null 接收响应数据 xhr.readyState // 属性 // 用于表示xhr对象的请求状态，一共5个状态 // 0：请求尚未初始化 // 1: 已经打开服务器连接，正在发送请求 // 2：接收响应头 // 3：接收响应主体 // 4：响应数据接收完毕 Ajax 请求代码 function show(){ //1.创建异步对象 var xhr = new XMLHttpRequest(); console.log(xhr); //4.绑定监听，接收响应 xhr.onreadystatechange=function(){ // onreadystatechange全程会调用4次 // 我们关注xhr.readyState==4 // 目的是，我们只要最后一次 if(xhr.readyState == 4&&xhr.status == 200){ //接收响应 var result = xhr.responseText; } } //2.打开连接，创建请求 xhr.open(\"get\", \"http://127.0.0.1:8080/login\", true); //3.发送请求 xhr.send(null); } 错误总结 跨域错误 会出现跨域错误。要使用服务器开启页面的方式打开 404，接口或者资源位置出错，前后台代码都需要排查 500 服务器代码错误，黑窗口会给你提示 不显示不报错----------一步一打桩 课后任务 %accordion%练习%accordion% 使用dom动态完成下面表格，数据。 %accordion% Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 21:29:30 "},"web/Ajax/Ajax-advanced.html":{"url":"web/Ajax/Ajax-advanced.html","title":"Ajax 高级","keywords":"","body":"Ajax 高级 代参数的get方法 xhr.open(\"get\", url, true) url=\"/demo/get_login?uname=\"+$uname+\"&upwd=\"+$upwd; function login() { //获取页面上用户的用户名和密码 var $uname = uname.value; var $upwd = upwd.value; //使用ajax访问服务器，并接受请求 //1.创建xhr异步对象 var xhr= new XMLHttpRequest(); //4.绑定监听，接受响应 xhr.onreadystatechange = function() { if(xhr.readyState == 4 && xhr.status == 200){ var result = xhr.responseText; alert(result); } } //2.创建请求，打开连接 xhr.open(\"get\",\"/demo/get_login?uname=\" + $uname + \"&upwd=\" + $upwd, true); //3.发送请求 xhr.send(); } restful规则的接口 restful接口定义规则/接口名称/:参数值&:参数值 [!warning|style:flat] 注意，使用restful不能把非空验证放到后台。 而要把非空验证在前端完成 post传参 [!warning|style:flat] xhr.send(formdata)必须带着请求主体发送 请求主体就是一个字符串 var formdata=\"uname=\"+$uname+\"&upwd=\"+$upwd; 在xhr.open和xhr.send之间，设置请求头信息 把content-type设置为可以发送特殊字符 xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); json解析 json是以js对象，或者js对象数组为表现形式字符串 // json 串 // JavaScript object notation // js 对象 表象方式 // json 的来源 // 1.可以手写json串 var str=\" { 'uid': 123 } \"; // 2.当服务器操作数据库之后，得到的result，在传递给前端之后自动就变成一个json json解析 [!Tip|style:flat] 把json字符串转换成js对象/js对象数组，这个行为就叫json解析 做json解析的目的，因为要对数据，使用js的api进行处理 json字符串的格式 [!Tip|style:flat] json中用一对{}来表示一个对象 json中所有的属性名称，必须使用双引号括起来 使用单引号，不会发生错误，但是建议使用双引号 json中的属性值，如果是字符串，也要带双引号 整个json是一个字符串，所以最外层要是用单引号包裹 json解析语法 var arr = JSON.parse(result); // arr 就是一个js的对象数组，可以使用js的数组操作模式了 xml解析 eXtensible markup language 可拓展的 标记 语言 所有的标签，属性都是自己定义xml就是做数据传递的，不用于数据展示 xml语法 [!Tip|style:flat] 首行做版本声明 xml标记，都是自己命名，只有双标记，没有单标记 xml标记，严格区分大小写，开始标记和结束标记必须一致 每个xml文档，有且只有一对根标记 错误总结 数据库没有开启 缺少括号 出乎意料的结尾，login这个方法未定义说明login方法中缺少} 符号错误 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 21:27:32 "},"web/Ajax/summary.html":{"url":"web/Ajax/summary.html","title":"Ajax 总结","keywords":"","body":"Ajax 总结 如果接口使用http的get方法 这个接口，可以使用浏览器的地址栏直接验证 [!NOTE|style:flat] 注意: restful的无参数get方法，和http的无参数get方法相同 restful的post方法，和http的post相同 功能模块编写思路 前端 后端 1. 收集整理数据---get，delete非空验证 2. ajax的xhr4步 3. 在if(xhr.readyState==4&........) 4. 中写dom操作，把得到响应数据呈现在html上 1. 接收前端传过来的数据 2. 写sql语句 3. 连接池进行数据操作 4. 返回的响应越短越好 课后任务 %accordion%提高题%accordion% 对注册的用户名，进行验证 逻辑： 1.失去焦点时调用 onblur 2.如果查到有这个用户名，说明当前用户名不可用 如果没有查到这个用户名，说明当前用户名可以注册 3.要创建要给bool的变量，当次变量为true的时候 可以注册，为false的时候不可以注册 4.用户名不可用，为false,两次输入密码不一致为false 某一个字段为空，为false %/accordion% Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 21:00:30 "},"web/jQuery/":{"url":"web/jQuery/","title":"jQuery","keywords":"","body":"jQuery 了解 jQuery 简单 解决了大部分浏览器兼容性问题 凡是 jQuery 让用的都没有兼容性问题 今后 pc 端的项目，以及主流框架底层，都是用 jQuery 实现的 jQuery 仅适用与 pc 端，不适用与移动版本 :::tip jQuery 官网 jQuery 官网手册 jQuery 中文手册 Github jQuery ::: jQuery 版本 版本: :::tip 1x 唯一支持旧浏览器的版本 2x 不在支持旧浏览器 3x 不在支持旧浏览器，而且添加了部分新功能 ::: 引入: :::tip 那个页面需要使用 jQuery 的简化版函数，都要先引入 jQuery.js 在编写自定义的 js 代码 ::: 出于性能的考虑: 所有的 js 代码的引入，都要放在 body 结尾。避免影响网页内容的加载 jQuery 的原理 当引入 jQuery.js 时 其实在 window 中添加了一中新类型的 jQuery jQuery类型也有两部分组成 1. 构造函数 function jQuery() {} 负责创建该类型的子对象 2. 原型对象 jQuery.prototype 负责保存该类型所有子对象中共有的函数 jQuery 简化版函数的三大特点 一个函数两用 jQuery 中没有属性，只有函数 比如: 获得按钮的内容 DOM: btn.innerHTML 修改 DOM 元素 DOM: btn.innerHTML = 新值 但是在 jQuery 中都是函数，没有属性，怎么实现对一个属性获取或添加操作 重载: 同一个函数，根据传入的参数不同，执行不同的操作 jQuery中: 一个修改属性的函数，如果没有给新值，就默认执行获取属性值的操作。如果给了新值参数，就变成修改属性值的操作 不如: 获得按钮内容 jQuery中: var 内容 = $btn.html(); -- 获取 修改按钮的内容 jQuery中: $btn.html(\"新值\"); -- 修改 :::tip 总结: jQuery 中凡是修改属性或内容的函数，都是一个函数两用。如果没有给新值，默认执行获取属性或内容的操作。如果给了新值，就变成了修改属性或内容的操作 ::: 自带遍历 :::tip 对 jQuery 类数组对象，调用一次简化版函数，等效于类数组对象内部保存的所有 DOM 元素，都调用一次函数 --- jQuery 对象自动的功能 ::: 查找元素 按选择器查找元素: /* jQuery 不但支持所有的 CSS 选择器，而且还增加了一批新增的 jQUery 专属选择器 */ 包括: css 中的子元素过滤 :first-child 作为其父元素下第一个子元素的所有元素 :last-child :nth-child(i) :only-child /* 总结: 根据元素在其父元素的相对下标位置选择元素。且序号从 1 开始 */ /* 基本过滤 jQuery 新增: */ /* 如果按照元素在其父元素内的相对位置选择器时 */ :first :last :eq(i) :lt(i) :gt(i) :even :odd 偶数 奇数 /* 特点: 先将符合条件的元素去出，统一放入一个集合中。按元素在集合中的编号选择元素。且下标从 0 开始 */ /* 今后希望打破父元素的界限，所有子元素统一编号，按位置找到元素时 */ :::warning 总结: 今后只要能用 css 做的效果，一定首选 css 做，因为 css 的效率就是比 js 高，且 css 没有框架和平台的兼容性问题。 即是 jQuery 中的选择器，也必须首选 css 选择器，css 选择器做不了的，才被迫选择 jQuery 新增的选择器。因为 jQuery 新增的选择器都是用 js 程序在底层模拟的————效率低的 ::: $ 的原理 创建 jQuery 对象，封装 DOM 元素 先查找在封装 $(\"选择器\") 直接封装 $(DOM元素) 经常 $(this) 或者 $(e.target) Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/jQuery/method.html":{"url":"web/jQuery/method.html","title":"方法使用","keywords":"","body":"方法使用 回顾属性选择器 css 中已有的 [属性名] [属性名 = 值] [属性名 ^= 值] [属性名 $= 值] [属性名 *= 值] jQuery 新增 用元素的内容文本作为查找条件 当元素的 class 或其它选择器无法区分这个元素时，就可以考虑用元素内容作为判断条件 1. :contains(文本) 选择元素内容中包含指定文本的元素 2. :has(选择器) 选择子元素中包含符合条件元素的父元素 可见性过滤: 1. visible 选择所有可见的元素 2. hidden 选择所有隐藏的元素 2. 修改 修改样式 ````css /* 获取修改内联样式 DOM: 元素.style.css属性 = \"值\" jq中: $元素.css(\"css属性\", \"值\") 简写: 控制显示隐藏 $元素.show() 等效于 .css(\"display\", \"block\") .hide() 等效于 .css(\"display\", \"none\") DOM 中获取样式不能用 .style，应为 .style 只能获得内联样式。所以 DOM 中被迫使用 getComputedStyle() 来获取计算后的样式 jQuery 中的 .css() 可自动切换 .style 和 getComputedStyle()。使用 .css() 即可修改样式，也可以获取所有样式 .css() 内部自动判断 如果没有给新的 css 属性值，就调用 getComputedStyle() 自动执行获取操作 如果给了新的 css 属性值，就自动切换成 .style.css 属性，执行操作 专门操作 class 函数 $元素.addClass(\"类名...\") $元素.removeClass(\"类名...\") let bool = $元素.hasClass(\"类名\") 判断一个元素是否包含某个 class 简化: 因为经常需要在有和没有某个 class 之间来回切换元素样式，所以今后，只要反复切换一个元素的 class 时，可简写为 $元素.toogleClass(\"\"); toogleClass 不能代替 addClass */ ```` 3. 按节点关系查找 父子关系 ```` DOM: 元素.parentNode 元素.childern 元素.firstElementChild 元素.lastElementChild jQ 中 $元素.parent() $元素.children([\"选择器\"]) 2. 兄弟关系 DOM: 元素.nextElementSibling 元素.previousElementSibling jQ 中: $元素.next() 之后一个兄弟元素 $元素.nextAll() 之后所有兄弟元素 $元素,prev() 之前一个兄弟元素 $元素.prevAll() 之前所有兄弟元素 $元素.siblings([\"选择器\"]) 除当元素外，所有平级的兄弟元素(不分前后) ## 4. 添加/删除/替换/克隆 1. 添加新元素 ````css /* DOM 3步 1. 创建空元素 2. 设置关键属性 3. 将新元素添加到 DOM 数 jq 中 2 步: 1. 用 $(html片段) 就可以创建片段中所有元素 let $a = $(`百度`) 2. 依然需要将新元素添加到 DOM 树上 jq 中: $父元素.append($新元素) $父元素.prepend($新元素) 开头插入 $现有元素.before($新元素) $现有元素.after($新元素) 之后插入 $现有元素.replaceWith($新元素) */ 删除元素 ````css /* DOM: 父元素.removeChild(子元素) jq 中: $任意元素.remove() 补充: .is() 专门判断一个元素是否符合条件 向判断一个元素是否符合指定的条件时 let bool $元素.is(\"选择器\") 如果 $ 元素符合\"选择器\"条件要求，则返回 true 如果 $ 元素不符合\"选择器\"条件要求，则返回 false */ ```` Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/jQuery/event.html":{"url":"web/jQuery/event.html","title":"事件操作","keywords":"","body":"事件操作 修改 克隆: // 复制一个和原 DOM 元素相同的一个新元素 let $新元素 = $现有元素.clone(); 事件绑定 事件绑定 DOM 中灵活的事件绑定 元素.addEventListener(\"事件名\", 处理函数) 元素.removeEventListener(\"事件名\", 处理函数名) jq 中共有几种事件绑定的方式 bind/unbind: 单纯的代替 addEventListener() 和 removeEventListener() 用法完全相同 事件委托 ```css /* DOM: 事件委托 3 件事 事件绑定在父元素上一次 用 e.target 代替 this 判断 e.target 是否想要的 jq 中: .delegate()/undelegate() 事件绑定在父元素上一次 this 又回来了 this. == e.target 不用自己写 if ($target.is(\"选择器\")) 而是将选择器作为参数交给 delegate() 请 delegate 自动判断当前元素是否符合要求 $父元素.delegate(\"选择器条件\", \"事件名\", function(){ ... $( this) }) */ ``` on/off(): 其实就是 bind 和 delegate 的封装 /* 重载方式 1. 直接个子元素绑定事件 $元素.on(\"事件名\", 处理函数) 等效于 bind() 等效于 addEnevtListener() 2. 如果利用事件委托时 $父元素.on(\"事件名\", \"选择器调价\", function(){ .... }) */ .事件名() 仅等效于 bind() 无法利用事件委托的优势 /* 强调: 只有 21 种常用的事件被简写了 除了 21 种之外，都不能简写 如: input 事件: 当文本输入一个文字后自动触发。 $txt.on(\"input\", function(){...}) */ 页面加载顺序 统称 js 代码(查找元素，事假绑定)都必须在页面内容加载完成，才能执行 将 js 放在 元素内容底部 通过绑定窗口事件 onload 事件 ```js window.addEventListener(\"load\", function(){ ... }) jq: $(winsow).load(function(){ ... }) - 在 onload 之前还有一个 DOMContentLoaded 事件 ```js // DOMContentLoaded 事件仅等待 html 和 js 加载完成就自动触发。不必等待 css 和图片比 onload 早的多 // DOMContentLoaded 有兼容性问题 // jq 中 $(document).ready(function(){ ... }) 简写: $(function(){ ... }); // 今后几乎所有的 jq 代码都要放在 $(function(){ ... }) 内。可以代替 js 中的匿名函数中。 :::tip 总结 大部分和 css 和图片无关的初始化操作，不如: 事件绑定，用过首选在 DOMContentLoaded，ajax 等 中提前执行 只要个别依赖于 css 和图片的初始化操作才被迫放在 window.onload 中 ::: $ 的原理 创建 jq 对象并查找元素 $(\"选择器\") 创建 jq 对象直接封装 DOM 元素 $(this) $(e.target) 创建新的 DOM 元素 $(\"html片段\") 绑定 DOM 内容加载后就提前执行的时间 $(function(){ ... }) 鼠标事件 DOM .mouseover 鼠标进入 .mouseout 鼠标移除 // 频繁进出子元素，也会冒泡触发父元素上的事件，容易引起误会 jq 中 mouseenter // 鼠标移入 mouseleave // 鼠标移除 模拟触发 $元素.trigger(\"事件名\") 动画 简单动画 显示隐藏 ```js .show() .hide() .show() .hide() // 不加参数时，默认使用 display: block 和display: none 控制瞬间显示隐藏 // 如果想有动画效果，必须加持续时间参数 - 上滑下滑 ```js .slideUp() .slideDown() 淡入淡出 .fadeIn() .fadeOut() 简单动画所有函数的共性 ``` 效果是写死的！几乎不可维护 用 js 定时器和 DOM 操作模拟器的动画效果 --- 效率极低 ``` 万能动画 可对任何 css 属性应用动画效果，只要希望对任意 css 属性应用动画效果时 $元素.animate({ css属性: 目标值 }, 动画持续事件) 让当前元素从现在的状态，经过指定的时间后缓慢过渡到目标状态 animate() 中只需要写目标值，animate() 可自动获得当前对应的属性值，自动计算变化的距离 也是 js 定时器和 DOM 操作模拟的动画效果 只支持单个数值的 css 属性，不支持 css3 动画，不支持颜色过渡 排队和并发 并发执行: 多个 css 属性同时变化 一个 animate() 内的多个 css 属性默认并发执行 排队执行: 多个 css 属性按顺序依次先后变化 对同一个元素先后调用多次 animate() 函数，多次 animate 函数中的 css 属性排队执行 停止动画 $元素.stop() ``` 默认只能停止当前正在播放的一个动画。如果队列中后续还有其它动画，则依然继续执行 $元素.stop(true) 停止当前动画，且清除动画队列 判断一个元素是否在播放 jQuery 动画 :animated 选择器 专门匹配正在播放的动画的元素 ## 类数组对象操作 > js 中类数组对象很受歧视，长得象数组，但是数组家好用的函数，类数组对象都用不了。但是 jq 中创建 jq 对象，都是类数组对象，于是 jQuery 就是 jq 对象，模拟出来两个和数组家功能相似的函数 - 遍历 ```js js 数组中: arr.forEach(function(elem, i, arr) {...}) jq 中: $(...)each(function(i, DOM元素) { ... }) // 依次去除.前的查找结果集合中的每个 DOM 元素，执行相同的操作 查找js 数组中: let i = indexOf(值); jq 中: let $i = $(查找结果).index(元素); // 查找元素在结果集合中的位置 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/jQuery/customize.html":{"url":"web/jQuery/customize.html","title":"添加自定义函数","keywords":"","body":"添加自定义函数 添加自定义函数 当项目中经常需要用的一个功能，但是 jQuery 没有提供简化版函数 其实就是定义一个函数，保存在 jQuery 类的原型对象中 jQuery 原型对象中的方法，可用 this 获得将来调用该函数的.前的 jq 对象。且不用在 $() 封装 this，应为 this 已经是 jQuery 子对象 简写: 其实 jQuery.fn = jQuery.prototype 所有: jQuery.prototype.sum = function() { ... } 可简写为: jQuery.fn.sum = function() { ... } 封装 jQuery 插件 什么是 jQuery 插件 拥有独立的 HTML，css，js 甚至是数据的可重用页面独立区域 以代码重用和简化开发 只要在项目中发现反复使用的页面功能区域，都需要封装插件，在反复使用欧冠插件 封装插件 jQuery 官方插件: jQuery UI 去官网 jQueryui.com 下载 jQueryUI 库引入 jquery-ui.css 引入 jquery.js 引入 jquery-ui.js 按照插件要求编写 html 代码，一个 css 都不用加 在自定义 找到插件的父元素，对父元素调用插件函数 原理: 侵入性: 不需要开发人员干预，插件函数可自动根据自身需要添加 class 和自定义扩展属性 优点: 省事 缺点: 可维护性差 封装插件 ```` 提取插件的 css 到一个独立的 css 文件中 笔试题: 如何避免组件样式之间的冲突 属于一个组件内的 class，都要统一以这个组件的父级 class 名开头，写完整路径 定义独立的 js 文件 向 jQuery 类型的原型对象中添加一个插件函数 自动侵入 class 自动绑定事件: 只需要将原来的 js 代码剪切到插件函数中，换一下主语 ```` 使用插件 ```` 引入插件 .css 引入 jquery.js 引入插件 .js 按照插件要求编写 html 内容，不用加 class 在自定义的 script 中，找到插件的父元素，为其调用插件函数 ```` Ajax $ajax({ url: \"服务端接口地址\", type: \"get或post\", data: {参数1: 值1, 参数2: 值2, ....}, dataType: \"json\", // 请 ajax 函数帮忙自动将 json 字符串转换为 js 对象或数组，可直接调用(自动调用JSON.parse()) success: function(result) { // 回调函数: 在请求成功后并成功接收到响应后，自动执行 // result 自动获得服务端返回的结构 } }); // 不用自己封装 ajax 跨域 什么是跨域 一个网站下载的网页，请求/使用了另一个网站下的资源 Ajax 不允许发送跨域请求 原理 一个网站的网页中发送的 ajax 请求，只能访问自己网站下提供的数据。不能访问别的网站提供的数据 允许发送请求 也能成功收到请求 浏览器会检查响应头，中的来源地址，如果来来源地址和当前网页所在的地址不同则禁止使用该数据，报错 跨域请求包括 1. 域名不同 http://www.a.com 下的网站 ajax 请求 -> http://www.b.com 2. 子级域名不同 http://oa.tedu.cn 下的网页 ajax 请求 -> http:hr.tedu.cn 3. 端口不同 http://localhost:5500 下的网页 ajax 请求 -> http://loaclost:3000 4. 协议不同 http://12306.com 下的网页 ajax 请求 -> https://12306.com 因为协议不同，其实就是端口号不同 http 协议默认是 80 端口 https 协议默认就是 443 端口 5. 即是同一台机器，相同的端口协议，ip 和域名之间互相访问，也算跨域 http://localhost:3000 下的页面 ajax 请求 -> hpp://127.0.0.1:3000 以上五中情况，都不允许 ajax 请求数据 解决跨域 2 种方法 CORS ``` 只需要服务端在返回数据时，在响应头中伪造来源地址，和客户端浏览器地址中的地址保持一致 伪装响应头: { \"Access-Control-Allow-Origin\": \"地址\" } 伪装响应头时，之写死一个客户地址，如果将来多个客户地址需要这个服务端数据，就不可兼得 解决: \"Access-Control-Origin\": \"*\" 可伪装成任意客户端地址，允许任意客户端都能访问这个服务端的数据 每个接口，都需要伪装响应头，每个接口在返回数据前，都要写 res.writeHead(200, {...}) 解决: nodejs 中 安装 cors 模块 npm install cors 并为 app.js 配置 cors 中间件 凡是进入 app.js 的请求，统一先伪装响应头，在进入路由处理数据 ``` JSONP: 暂未添加文档 前后端分离 将来的项目都是前端和后端两个项目独立开发 两个项目之间的练习，仅仅靠接口地址 后端: 只负责编写服务程序，并抛出接口地址 前端: 通过 ajax 请求，请求服务端接口地址，提交/获取服务端数据，实现页面交互功能 前后端分离核心技术: ajax 和跨域请求 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"web/TypeScript/":{"url":"web/TypeScript/","title":"TypeScript","keywords":"","body":"TypeScript 简介 TypeScript 其实就是 JavaScript 的超集，也就是说 TypeScript 是建立在 JavaScript 之上的，最后都会转变成 JavaScript。 必备依赖 node.js 全局安装 typeScript npm install typescript -g || yarn global add typescript 建立项目目录和编译 TS 文件 Demo1.ts function kiven() { let web: string = \"Hello World\"; console.log(web); } kiven(); cmd tsc Demo1.ts 转换 node Demo1.js 输出 ts-node 的安装和使用 全局安装 npm install -g ts-node 命令中直接输入如下命令 ts-node Demo1.ts 使用ts-node就可以直接看到编写结果 数据类型 Undefined : 赋予任何值的时候，他就是Undefined类型 //声明数值类型的变量age，但不予赋值 var age:number console.log(age) Number:数值类型; var age:number = 18 var stature:number = 178.5 console.log(age) console.log(stature) string : 字符串类型; var kiven:string = \"kiven.com\" console.log(kiven) Boolean: 布尔类型； var b:boolean = true var c:boolean = false enum：枚举类型； 变量的结果是固定的几个数据时 enum REN{ nan , nv ,yao} console.log(REN.yao) //返回了2，这是索引index，跟数组很想。 枚举赋值 enum REN{ nan = '男', nv = '女', yao= '妖' } console.log(REN.yao) //返回了妖 这个字 any : 任意类型，一个牛X的类型； 程序中不断变化着类型，又不想让程序报错 var t:any =10 t = \"kiven\" t = true console.log(t) void：空类型； Array : 数组类型; Tuple : 元祖类型； Null ：空类型。 函数 定义函数 function searchXiaoJieJie(age:number):string{ return '找到了'+age+'岁的小姐姐' } var age:number = 18 var result:string = searchXiaoJieJie(age) console.log(result) 需要注意的是： 声明（定义）函数必须加 function 关键字； 函数名与变量名一样，命名规则按照标识符规则； 函数参数可有可无，多个参数之间用逗号隔开； 每个参数参数由名字与类型组成，之间用分号隔开； 函数的返回值可有可无，没有时，返回类型为 void； 大括号中是函数体。 形参和实参 形参的使用 定义了形参也就规定了此函数的参数个数和参数类型，规范了函数。 function searchXiaoJieJie(age:number):string{ return '找到了'+age+'岁的小姐姐' } 实参的使用 var result:string = searchXiaoJieJie(age) 每一个实参的类型要与对应的形参类型一致。 函数参数 函数的形参分为：可选形参、默认形参、剩余参数形参等。 可选参数的函数 这种参数，在定义函数的时候通过?标注。 function searchXiaoJieJie2(age:number,stature?:string):string{ let yy:string = '' yy = '找到了'+age+'岁' if(stature !=undefined){ yy = yy + stature } return yy+'的小姐姐' } var result:string = searchXiaoJieJie2(22,'大长腿') console.log(result) 有默认参数的函数 不传递参数的时候，给一个默认值，而不是undefined function searchXiaoJieJie2(age:number=18,stature:string='大胸'):string{ let yy:string = '' yy = '找到了'+age+'岁' if(stature !=undefined){ yy = yy + stature } return yy+'的小姐姐' } var result:string = searchXiaoJieJie2() console.log(result) 有剩余参数的函数 传递给函数的参数个数不确定。 function searchXiaoJieJie3(...xuqiu:string[]):string{ let yy:string = '找到了' for (let i =0;i 函数参数&&返回类型定义 简单类型定义 demo5.ts function getTotal(one: number, two: number) { return one + two; } const total = getTotal(1, 2); 代码写错 function getTotal(one: number, two: number) { return one + two + \"\"; } const total = getTotal(1, 2); total的值就不是number类型 不会报错 函数的返回值加上类型注解 function getTotal(one: number, two: number): number { return one + two; } const total = getTotal(1, 2); 尽量让自己的代码更加严谨。 函数无返回值时定义方法 定义一个sayHello的函数 function sayHello(): void { console.log(\"hello world\"); } 给他一个类型注解void，代表没有任何返回值。 never 返回值类型 如果一个函数是永远也执行不完的，就可以定义返回值为never 抛出异常 function errorFuntion(): never { throw new Error(); console.log(\"Hello World\"); } 死循环 function forNever(): never { while (true) {} console.log(\"Hello kiven\"); } 函数参数为对象(解构) 当一个函数的参数是对象 定义参数对象的属性类型javaScript function add({ one, two }) { return one + two; } const total = add({ one: 1, two: 2 }); 参数加类型注解 function add({ one, two }: { one: number, two: number }): number { return one + two; } const three = add({ one: 1, two: 2 }); 参数是对象，并且里边只有一个属性 function getNumber({ one }: { one: number }): number { return one; } const one = getNumber({ one: 1 }); 三种函数的定义方式 函数声明法 使用function关键字和函数名去定义一个函数。 function add(n1:number,n2:number):number{ return n1+n2 } 函数表达式 函数表达式法是将一个函数赋值给一个变量 这个变量名就是函数名。 var add = function(n1:number,n2:number):number{ return n1+n2 } console.log(add(1,4)) 箭头函数 箭头函数定义的函数一般都用于回调函数中。 var add = (n1:number,n2:number):number=>{ return n1+n2 } console.log(add(1,4)) 函数中变量作用域 每个变量都有一个起作用的范围，这个范围就是变量的作用域。在TypeScript语言中变量作用域划分是以函数为标准的。 function zhengXing():void{ var yangzi = 'King' console.log(yangzi) } zhengXing() console.log(yangzi) 函数里用var定义一个yangzi的变量,我们再函数的外部读取这个变量，你会发现是读取不到的。 全局变量and局部变量 局部变量：函数体内定义的变量就是局部变量。 全局变量: 函数体外 定义的变量就是全局变量。 局部变量和全局变量重名 当局部变量与全局变量重名的时候，在函数体内是局部变量起作用；如果重名，就有变量提升 let关键字变量的作用域 作用域的划分是以一对大括号作为界限的 使用let关键字的变量就是一个块级作用域变量 function zhengXing():void{ var yangzia:string = '刘德华' { let yangzib:string = '小沈阳' console.log('凯文整形成了'+yangzib+'的样子') } console.log('凯文整形成了'+yangzia+'的样子') console.log('凯文整形成了'+yangzib+'的样子') } zhengXing() 数组 TypeScript中的数据分为值类型和引用类型。 初识引用类型 let kiven = { name:'凯文', website:'kiven.com', age:18, saySometing:function(){ console.log('为了前端技术') } } console.log(kiven.name) kiven.saySometing() 引用类型，例如：Array（数组）、String（字符串）、Date（日期对象）、RegExp（正则表达式) 初始化数组的两种方法 声明数组的方法 let arr1:number[ ] //声明一个数值类型的数组 let arr2:Array //声明一个字符串类型的数组 给数组赋值 数组是存储大量数据的集合，声明数组之后，需要给数组存储数据。这时候有两种方法： 字面量赋值法：直接使用“[ ]”对数组进行赋值。 构造函数赋值法： 字面量赋值法 //定义一个空数组，数组容量为0 let arr1:number[] = [] //定义一个数组时，直接给数组赋值 let arr2:number[] = [1,2,3,4,5] //定义数组的同时给数组赋值 let arr3:Array = ['kiven','凯文','金三胖'] let arr4:Array = [ true,false,false] 【注】TypeScript中指定数据类型的数组只能存储同一类型的数组元素。 构造函数赋值法 let arr1:number[] = new Array() let ara2:number[] = new Array(1,2,3,4,5) let arr3:Array = new Array('kiven','凯文','金三胖') let arr4:Array = new Array(true,false,false) 多种类型如何定义 const arr: (number | string)[] = [1, \"string\", 2]; 对象类型的定义 const xiaoJieJies: { name: string, age: Number }[] = [ { name: \"King\", age: 18 }, { name: \"Tom\", age: 28 }, ]; 定义一个Lady的别名。 type Lady = { name: string, age: Number }; 改变形式 type Lady = { name: string, age: Number }; const xiaoJieJies: Lady[] = [ { name: \"King\", age: 18 }, { name: \"Tom\", age: 28 }, ]; 定义类限制数组 class Madam { name: string; age: number; } const xiaoJieJies: Madam[] = [ { name: \"King\", age: 18 }, { name: \"Tom\", age: 28 }, ]; 元组 元组和数组类似，但是类型注解时会不一样。 const xiaojiejie: [string, string, number] = [\"dajiao\", \"teacher\", 28]; 数组中的每个元素类型的位置给固定住了，这就叫做元组。 元组的使用 数据源CSV 严谨的编程就需要用到元组 \"dajiao\", \"teacher\", 28; \"liuying\", \"teacher\", 18; \"cuihua\", \"teacher\", 25; const xiaojiejies: [string, string, number][] = [ [\"dajiao\", \"teacher\", 28], [\"liuying\", \"teacher\", 18], [\"cuihua\", \"teacher\", 25], ]; 字符串 字符串的两种类型 基本类型字符串：由单引号或者双引号括起来的一串字符串。 引用类型字符串：用new 实例化的 String类型。 定义字符串 let kiven:string = '凯文' let kivena:String = new String(\"kiven.com\") console.log(kiven) console.log(kivena) 获取字符串长度 kiven.length 常用字符串Api 查找字符串 头部查找字符串直接使用indexOf 基本语法：str.indexOf(subStr) 字符串没有找到，则返回-1。返回的都是字符串的下标 截取字符串 基本语法如下： str.substring(startIndex,[endIndex]) 替换字符串 基本语法如下： str.replace(subStr,newstr); 日期对象 let d:Date = new Date() console.log(d) 2018-09-06T06:48:12.504Z 传递表示年月日时分秒的变量 let d:Date = new Date(year,month,day,hours,minutes,seconds,ms); year 表示年份，4位数字。 month表示月份，数值是0(1月)~11(12月)之间的整数。 day 表示日期。数值是1~31之间的整数。 hours 表示小时，数值是0-23之间的整数。 minutes 表示分钟数，数值是0~59之间的整数。 seconds 表示秒数，数值是0~59之间的整数。 ms 表示毫秒数，数值是0~999之间的整数。 正则表达式 比如g是全局修饰符，i是忽略大小写，m是多行模式。 let reg1:RegExp = new RegExp(\"kiven\") //表示字符串规则里含有kiven console.log(reg1) let reg2:RegExp = new RegExp(\"kiven\",'gi') console.log(reg2) 字面量法 let reg3:RegExp = /kiven/ let reg4:RegExp = /kiven/gi RegExp中的常用方法 RegExp对象包含两个方法：test( )和exec( ),功能基本相似，用于测试字符串匹配。 test(string) ：在字符串中查找是否存在指定的正则表达式并返回布尔值，如果存在则返回 true，不存在则返回 false。 exec(string) : 用于在字符串中查找指定正则表达式，如果 exec() 方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回 null。 let reg1:RegExp = /kiven/i let website:string = 'kiven.com' let result:boolean = reg1.test(website) console.log(result) //true exec的使用方法 let reg1:RegExp = /kiven/i let website:string = 'kiven.com' console.log(reg1.exec(website)) //[ 'kiven', index: 0, input: 'kiven.com' ] 面向对象编程 类定义 class XiaoJieJie{ name:string; age:number; constructor(name:string,age:number){ this.name = name this.age = age } say(){ console.log('小哥哥好') } } let jiejie:XiaoJieJie = new XiaoJieJie('范冰冰',18) console.log(jiejie) jiejie.say() constructor为构造函数 作用是给类中封装的属性进行赋值。 类继承 class lady{ content = 'Hi ,帅哥' sayHello() { return this.content } } class Xiaomeimei extends lady { sayHello() { return super.sayHello()+'. 你好'//调用父类 } sayLove() { return + \"I Love you\" } } const goodess = new Xiaomeimei() console.log(goodess.sayHello()); console.log(goodess.sayLove()); 类的访问类型 // 类的访问类型 class Person { name: string; } const person = new Person() person.name = 'kiven' console.log(person.name) 修饰符 public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。 protected:受保护的修饰符，只允许再类的内部被调用，外部不允许调用 private : 私有修饰符，允许在类内及继承的子类中使用 class XiaoJieJie2{ public sex:string protected name:string private age:number public constructor(sex:string,name:string,age:number){ this.sex=sex this.name=name this.age=age } public sayHello(){ console.log('小哥哥好') } protected sayLove(){ console.log('我爱你') } } var jiejie2:XiaoJieJie2 = new XiaoJieJie2('女','热巴',22) console.log(jiejie2.sex) console.log(jiejie2.name) //报错 console.log(jiejie2.age) //报错 jiejie2.sayHello() jiejie2.sayLove() //报错 只读属性修饰符 使用readonly修饰符将属性设置为只读，只读属性必须在生命时或者构造函数里被初始化 class Man{ public readonly sex:string = '男' } var man:Man = new Man() man.sex='女' 类的构造函数 类被初始化·是 自动执行的一个方法 //类的构造函数 class Person{ constructor(public name:string){} } class Teacher extends Person { // 子类 如果使用constructor 必须实现 父类方法 constructor(public age: number) { super('kiven') } } const teacher= new Teacher(18) console.log(teacher.name) console.log(teacher.age) 子类只要写 构造函数 必须 super 才可不报错 类的Getter Setter class Nvhai { constructor(private _age:number){} get age(){ return this._age-10 } set age(age:number){ this._age=age } } const nvhai = new Nvhai(28) nvhai.age=25 console.log(nvhai.age) setter也是可以保护私有变量 set age(age:number){ this._age=age+3 } 静态类 class Gir { static sayLove() { return 'I love you!' } } console.log(Gir.sayLove()) 抽象类 class Waiter {} class BaseTeacher {} class seniorTeacher {} 定义抽象方法 abstract class Girl{ abstract skill() //因为没有具体的方法，所以我们这里不写括号 } class Waiter extends Girl{ skill(){ console.log('先生，请喝水！') } } class BaseTeacher extends Girl{ skill(){ console.log('先生，来个泰式按摩吧！') } } class seniorTeacher extends Girl{ skill(){ console.log('先生，来个SPA全身按摩吧！') } } 继承和重写 继承：允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。 class kiven{ public name:string public age : number public skill: string constructor(name:string,age:number,skill:string){ this.name = name this.age = age this.skill = skill } public interest(){ console.log('找小姐姐') } } let kivenObj:kiven = new kiven('凯文',18,'web') kivenObj.interest() extends关键字就是继承的重点 class JsShuai extends kiven{ public xingxiang:string = '帅气' public zhuangQian(){ console.log('一天赚了一个亿') } } let shuai = new JsShuai(\"技术帅\",5,'演讲') shuai.interest() shuai.zhuangQian() 类方法的重写 class JsShuai extends kiven{ public xingxiang:string = '帅气' public interest(){ super.interest() console.log('建立电商平台') } public zhuangQian(){ console.log('一天赚了一个亿') } } super关键字调用了父类的方法，实现了技能的增加。 接口 定义接口的关键字是interface interface Husband { sex:string interest:string } let myhusband:Husband ={ sex:'男',interest:'看书、作家务'} console.log(myhusband) 接口方法 没有进行接口优化代码 const screenResume = (name: string, age: number, bust: number) => { age =90 && console.log(name+\"进入面试\") age >=24 || bust { console.log( name+'年龄是'+age) console.log( name+'胸围是'+bust) } screenResume('珈百璃', 18, 59) screenResume('波多野结衣', 18, 94) 接口优化 //接口类型注解 interface Girl { name: string; age: number; bust: number; } const screenResume = (girl: Girl) => { girl.age = 90 && console.log(girl.name + \"进入面试\"); girl.age > 24 || (girl.bust { console.log(girl.name + \"年龄是：\" + girl.age); console.log(girl.name + \"胸围是：\" + girl.bust); }; const girl = { name: \"桥本环奈\", age: 18, bust: 94, }; screenResume(girl); getResume(girl); 可选参数的接口 interface Husband { sex:string interest:string maiBaoBao?:Boolean //可选参数接口 } let myhusband:Husband ={ sex:'男',interest:'看书、作家务',maiBaoBao:true} console.log(myhusband) 规范函数类型接口 interface SearchMan{ (source:string,subString:string):boolean } let mySearch:SearchMan mySearch = function(source:string,subString:string):boolean{ let flag =source.search(subString) return (flag != -1) } console.log(mySearch('高、富、帅、德','胖')) //false 接口和类型别名的区别 类型别名可以直接给类型，比如string，而接口必须代表对象。 类型别名 type Girl1 = stirng; girl const girl = { name: \"桥本环奈\", age: 18, bust: 94, }; 允许加入任意值 interface Girl { name: string; age: number; bust: number; waistline?: number; [propname: string]: any; } 属性的名字是字符串类型，属性的值可以是任何类型 接口的方法 interface Girl { name: string; age: number; bust: number; waistline?: number; [propname: string]: any; //属性名称string 类型任何 say(): string; } const girl = { name: \"波多野结衣\", age: 18, bust: 94, waistline: 21, sex: \"女\", say() { return \"欢迎光临 ，红浪漫洗浴！！\"; }, }; 接口限制类 // 接口限制类 class Xiaojiejie implements Girl { name: \"小仓唯\" age: 18 bust: 94 waistline: 21 sex: \"女\" say() { return \"欢迎光临 ，红浪漫洗浴！！\"; } } implements 关键字 接口间的继承 Teacher接口，继承于Person接口。 interface Teacher extends Girl { teach(): string; } const getResume = (girl: Teacher) => { console.log(girl.name + \"年龄是：\" + girl.age); console.log(girl.name + \"胸围是：\" + girl.bust); girl.waistline && console.log(girl.name + \"腰围是：\" + girl.waistline); girl.sex && console.log(girl.name + \"性别是：\" + girl.sex); }; 传值必须有Teach方法 const girl = { name: \"桥本环奈\", age: 18, bust: 94, waistline: 21, sex: \"女\", say() { return \"欢迎光临 ，红浪漫洗浴！！\"; }, teach() { return \"我是一个老师\"; }, }; 命名空间 命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。 namespace shuaiGe{ export class Dehua{ public name:string = '刘德华' talk(){ console.log('我是帅哥刘德华') } } } namespace bajie{ export class Dehua{ public name:string = '马德华' talk(){ console.log('我是二师兄马德华') } } } let dehua1:shuaiGe.Dehua = new shuaiGe.Dehua() let dehua2:shuaiGe.Dehua = new bajie.Dehua() dehua1.talk() TypeScript 静态类型 TypeScript 的一个最主要特点就是可以定义静态类型(Static Typing) 如何定义 const count: number = 1; 自定义静态类型 interface Xiaojiejie{ uname: String; age: Number; } const nai: Xiaojiejie = { uname: \"桥本环奈\", age: 18, } console.log(nai.age); 如果使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了 大大提高了程序的健壮性 基础静态类型&&对象类型 基础静态类型 const count : number = 918; const myName ：string = 'kiven' 类似这样常用的基础类型还有: null,undefinde,symbol,boolean,void 对象类型 const xiaoJieJie: { name: string, age: number, } = { name: \"King\", age: 18, }; console.log(xiaoJieJie.name); 经典的对象类型 对象类型也可以是数组 const xiaojiejie: String[] = [\"波多野结衣\", \"花泽香菜\"] 数组里的内容必须是字符串 用类的形式，来定义变量 class Person {} const dajiao: Person = new Person(); 定义一个函数类型，并确定返回值 //定义函数类型 并确定返回值 const huaze :() => string = () => { return \"花泽香菜\"} 对象类型可以有几种形式： 对象类型 数组类型 类类型 函数类型 类型注解&&类型推断 (type annotation)类型注解 let count: number; count = 123; count变量就是一个数字类型，这就叫做`类型注解 (type inferrence) 类型推断 let countInference = 123; TypeScript 自动把变量注释为了number（数字）类型 工作(潜规则) 如果 TS 能够自动分析变量类型， 我们就什么也不需要做了 如果 TS 无法分析变量类型的话， 我们就需要使用类型注解 不用写类型注解的例子： const one = 1; const two = 2; const three = one + two; 再来看一个用写类型注解的例子： function getTotal(one, two) { return one + two; } const total = getTotal(1, 2); 因为这里的one和two会显示为any类型。 必须加一个类型注解 function getTotal(one: number, two: number) { return one + two; } const total = getTotal(1, 2); TypeScript 也可以推断出对象中属性的类型 const XiaoJieJie = { name: \"刘英\", age: 18, }; 数组类型注解 // 数组类型注解 const numberArr: number[] = [1, 2, 3] const arr: (number | string)[] = [1, 'string', 2] const xioameimei:{name:string,age:number}[] = [ { name: '桥本环奈', age: 18 }, { name: '小仓唯', age: 18 } ] type alias 类型别名 type Lady={name:string,age:number} const xiaojiejie:Lady[] = [ { name: '桥本环奈', age: 18 }, { name: '小仓唯', age: 18 } ] 类的形式 进行注解 class Madam { name: string; age: number; } const xiaomeimei:Madam[] = [ { name: '桥本环奈', age: 18 }, { name: '小仓唯', age: 18 } ] 联合类型和类型保护 所谓联合类型，可以认为一个变量可能有两种或两种以上的类型。关键符号是| interface Waiter { anjiao: boolean; say: () => {}; } interface Teacher { anjiao: boolean; skill: () => {}; } function judgeWho(animal: Waiter | Teacher) {} function judgeWho(animal: Waiter | Teacher) { animal.say(); } 如果直接写一个这样的方法，会报错因为judgeWho不能准确的判断联合类型具体的实例是什么。 概念叫做类型保护 类型保护 类型断言 类型断言就是通过断言的方式确定传递过来的准确值 interface Waiter { anjiao: boolean; say: () => {}; } interface Teacher { anjiao: boolean; skill: () => {}; } function judgeWho(animal: Waiter | Teacher) { //如果存在 if (animal.anjiao) { (animal as Teacher).skill(); }else{ (animal as Waiter).say(); } } in 语法 我们还经常使用in语法来作类型保护，比如用if来判断animal里有没有skill()方法。 function judgeWhoTwo(animal: Waiter | Teacher) { if (\"skill\" in animal) { animal.skill(); } else { animal.say(); } } typeof 语法 add 方法 function add(first: string | number, second: string | number) { return first + second; } 不做任何的类型保护，只是相加 产生报错 正确写法 function add(first: string | number, second: string | number) { if (typeof first === \"string\" || typeof second === \"string\") { return `${first}${second}`; } return first + second; } instanceof 语法 类型保护的是一个对象 class NumberObj { count: number; } 未添加类型保护【报错】 function addObj(first: object | NumberObj, second: object | NumberObj) { return first.count + second.count; } 正确写法 function addObj(first: object | NumberObj, second: object | NumberObj) { if (first instanceof NumberObj && second instanceof NumberObj) { return first.count + second.count; } return 0; } instanceof语法进行判断，instanceof 只能用在类上。 Enum 枚举类型 如果在程序中能灵活的使用枚举(enum),会让程序有更好的可读性 低级 function getServe(status: number) { if (status === 0) { return \"massage\"; } else if (status === 1) { return \"SPA\"; } else if (status === 2) { return \"dabaojian\"; } } const result = getServe(0); console.log(`我要去${result}`); 中级 const Status = { MASSAGE: 0, SPA: 1, DABAOJIAN: 2, }; function getServe(status: any) { if (status === Status.MASSAGE) { return \"massage\"; } else if (status === Status.SPA) { return \"spa\"; } else if (status === Status.DABAOJIAN) { return \"dabaojian\"; } } const result = getServe(Status.SPA); console.log(`我要去${result}`); 高级 enum Status { MASSAGE, SPA, DABAOJIAN, } function getServe(status: any) { if (status === Status.MASSAGE) { return \"massage\"; } else if (status === Status.SPA) { return \"spa\"; } else if (status === Status.DABAOJIAN) { return \"dabaojian\"; } } const result = getServe(Status.SPA); console.log(`我要去${result}`); 枚举类型的对应值 const result = getServe(1); 枚举类型是有对应的数字值的，默认是从 0 开始的 console.log(Status.MASSAGE); console.log(Status.SPA); console.log(Status.DABAOJIAN); 结果就是0,1,2。那这时候不想默认从 0 开始，而是想从 1 开始 enum Status { MASSAGE = 1, SPA, DABAOJIAN, } 枚举通过下标反查 console.log(Status.MASSAGE, Status[1]); 函数泛型 联合类型 Demo 简单的join方法 ，字符串的基本拼接 function join(first: string | number, second: string | number) { return `${first}${second}`; } join(\"kiven\", \".com\"); 实现需求 就是first参数如果传的是字符串类型，要求second也传字符串类型 初始泛型概念-generic 泛型：[generic - 通用、泛指的意思],那最简单的理解，泛型就是泛指的类型。 泛型的定义使用<> function join(first: kiven, second: kiven) { return `${first}${second}`; } join (\"kiven\", \".com\"); 如果要是number类型 就直接在调用方法的时候进行更改 join (1, 2); 泛型中数组的使用 如果传递过来的值要求是数字，如何用泛型进行定义 第一种是直接使用[]， function myFun(params: ANY[]) { return params; } myFun [\"123\", \"456\"]; 第二种是使用Array function myFun(params: Array) { return params; } myFun [\"123\", \"456\"]; 经常使用来作泛型的表示 多个泛型的定义 定义多个泛型，比如第一个泛型用T,第二个用P代表。 function join(first: T, second: P) { return `${first}${second}`; } join (1, \"2\"); 泛型在造轮子的时候经常使用，因为造轮子很多东西都需要灵活性。 如果函数定义了多个泛型，使用时要对应的定义出具体的类型。 泛型的类型推断 function join(first: T, second: P) { return `${first}${second}`; } join(1, \"2\"); 类中泛型 基本类 类SelectGirl 类的构造函数中(constructor) class SelectGirl { constructor(private girls: string[]) {} getGirl(index: number): string { return this.girls[index]; } } const selectGirl = new SelectGirl([\"桥本环奈\", \"小仓唯\", \"珈百璃\"]); console.log(selectGirl.getGirl(1)); 编写复杂代码的时候，会经常使用泛型。 class SelectGirl { constructor(private girls: string[] | number[]) {} getGirl(index: number): string | number { return this.girls[index]; } } 初始类的泛型 用泛型重构代码 用<>编写 //使用泛型。 class SelectGirl { constructor(private girls:T[]) {} getGirl(index: number):T { return this.girls[index]; } } // 通过推断方式 判断类型 // 需要在实例化对象的时候，对泛型的值进行确定 const selectGirl = new SelectGirl([\"桥本环奈\", \"小仓唯\", \"珈百璃\"]); console.log(selectGirl.getGirl(1)); 泛型中的继承 要求返回是一个对象中的name return this.girls[index].name; 写一个Girl的接口 每个接口里都要有 name 属性 interface Girl { name: string; } 有了接口后用extends关键字实现泛型继承 class SelectGirl { ... } 这句代码的意思是泛型里必须有一个name属性，因为它继承了Girl接口。 因为我们getGirl方法的返回类型还不对，这时候应该是一个string类型才对 interface Girl { name: string; } //使用泛型。 继承必须返回 name class SelectGirl { constructor(private girls:T[]) {} getGirl(index: number):string { return this.girls[index].name; } } // 通过推断方式 const selectGirl = new SelectGirl([ { name: \"桥本环奈\" }, { name: \"小仓唯\" }, { name: \"珈百璃\" }, ]); console.log(selectGirl.getGirl(1)); SelectGirl类中使用了泛型 有一个约束条件，这个类型，必须要有一个name属性 泛型约束 泛型可以是任意类型，可以是对象、字符串、布尔、数字都是可以的 interface Girl { name: string; } //使用泛型。 继承必须返回 name class SelectGirl { constructor(private girls:T[]) {} getGirl(index: number):T { return this.girls[index]; } } // 通过推断方式 const selectGirl = new SelectGirl([\"桥本环奈\", \"小仓唯\", \"珈百璃\"]); console.log(selectGirl.getGirl(1)); 泛型必须是string或者number类型 关键字extends来进行约束 class SelectGirl { //..... } 命名空间 TSWeb 空文件 建立好文件夹后，打开 VSCode，把文件夹拉到编辑器当中，然后打开终端，运行npm init -y,创建package.json文件。 生成文件后，我们接着在终端中运行tsc -init,生成tsconfig.json文件。 新建src和build文件夹，再建一个index.html文件。 在src目录下，新建一个page.ts文件，这就是我们要编写的ts文件了。 配置tsconfig.json文件，设置outDir和rootDir(在 15 行左右)，也就是设置需要编译的文件目录，和编译好的文件目录。 \"outDir\": \"./build\", \"rootDir\": \"./src\", 然后编写index.html，引入,当让我们现在还没有page.js文件。 编写page.ts文件，加入一句输出console.log('kiven.com'),再在控制台输入tsc,就会生成page.js文件 再到浏览器中查看index.html文件，如果按F12可以看到kiven.com，说明我们的搭建正常了。 Document TypeScript来进行编写 没有命名空间 用类的形式在index.html中实现header,content和Footer部分，类似我们常说的模板。 page.ts class Header { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Header\"; document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Content\"; document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Footer\"; document.body.appendChild(elem); } } class Page { constructor() { new Header(); new Content(); new Footer(); } } tsc进行编译 修改index.html文件 标签里引入标签，并实例化`Page new Page(); ./build/page.js文件可以看出全部都是var声明的变量）。 过多的全局变量会让我们代码变的不可维护 只要有Page这个全局变量就足够了，剩下的可以模块化封装起来，不暴露到全局。 命名空间的使用 命名空间这个语法，很类似编程中常说的模块化思想 比如webpack打包时 命名空间声明的关键词是namespace 比如声明一个namespace Home,需要暴露出去的类，可以使用export关键词 namespace Home { class Header { constructor() { const elem = document.createElement('div') elem.innerHTML = \"This is Header\" document.body.appendChild(elem); } } class Content { constructor() { const elem = document.createElement('div') elem.innerHTML = \"This is Content\" document.body.appendChild(elem); } } class Footer { constructor() { const elem = document.createElement('div') elem.innerHTML = \"This is Footer\" document.body.appendChild(elem); } } // 实例化 export class Page { constructor() { new Header(); new Content(); new Footer(); } } } TS 代码写完后，再到index.html文件中进行修改，用命名空间的形式进行调用，就可以正常了。 写完后，记得用tsc编译一下，当然你也可以使用tsc -w进行监视了，只要有改变就会进行重新编译。 Document new Home.Page() 浏览器中进行查看 可以看到现在就只有Home.Page 其他的Home.Header...这些都是得不到的 只有Home.Page是全局的，其他的都是模块化私有的。 深入命名空间 单独写一个components的文件，然后进行组件化。 在src目录下新建一个文件components.ts namespace Components { //导出组件 export class Header { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Header\"; document.body.appendChild(elem); } } export class Content { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Content\"; document.body.appendChild(elem); } } export class Footer { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Footer\"; document.body.appendChild(elem); } } } 导出后就可以在page.ts中使用这些组件 namespace Home { export class Page { constructor() { new Components.Header(); new Components.Content(); new Components.Footer(); } } } tsc进行重新编译 必须要在index.html里进行引入components.js文件 多文件编译成一个文件 打开tsconfig.json文件，然后找到outFile配置项 如果设置了它，就不再支持\"module\":\"commonjs\" 改成\"module\":\"amd\" { \"outFile\": \"./build/page.js\" } 配置好后，删除掉build下的js文件，然后用tsc进行再次编译。 删掉index.html文件中的component.js 可以正常运行 --> 子命名空间 namespace Components { export namespace SubComponents { export class Test {} } //someting ... } 使用 import 语法 修改 components.ts 文件 写成 ES6 的 export 导出模式 export class Header { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Header\"; document.body.appendChild(elem); } } export class Content { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Content\"; document.body.appendChild(elem); } } export class Footer { constructor() { const elem = document.createElement(\"div\"); elem.innerText = \"This is Footer\"; document.body.appendChild(elem); } } 三个类就都已经用export导出了，也就是说可以实现用import进行引入了 修改 page.ts 文件 import { Header, Content, Footer } from \"./components\"; export class Page { constructor() { new Header(); new Content(); new Footer(); } } tsc进行编译 可以看到编译好的代码都是define开头 这种代码在浏览器中是没办法被直接运行 需要其他库(require.js) Require.js 的 CDN 地址： https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js 引入 require.js 这时候就可以解析define这样的语法 page.ts中加入default关键字，如果不加是没办法直接引用到的。 tsc进行编译一下 export default这种形式的语法，需要在html里用require来进行引入。 require 方式引入 因为你已经加入了require.js这个库，所以现在可以直接在代码中使用require了 require([\"page\"], function (page) { new page.default(); }); 用 Parcel 打包Ts代码 建立一个新项目 新建立一个项目TSTest 打开终端，输入npm init -y,创建package.json文件 在终端中输入tsc --init,创建tsconfig.json文件 修改tsconfig.json配置rootDir和outDir. 新建src文件夹，在里边建立index.html,page.ts文件 编写index.html文件，并引入page.ts文件 编写page.ts文件。 index.html 文件代码： Document page.ts 文件代码： const teacher: string = \"kiven\"; console.log(teacher); 这时候我们并不能正常的预览出效果 需要Parcel Parcel 的安装和使用 yarn add --dev parcel@next 安装好以后，打开package.json文件 实例版本^2.0.0-beta.1 package.json { \"scripts\": { \"test\": \"parcel ./src/index.html\" }, } 使用parcel对index.html进行编译 终端输入yarn test 这说明Parcel会自动对index.html中引入的TypeScript文件进行编译 Ts使用JQuery TypeScript 的代码中使用其他类库 涉及到一个类型文件(Type file)的问题 引入 JQuery 框架库 在TSTest文件夹的src目录下，引入JQuery文件 这里采用CDN的形式进行引入 有了 jquery 框架，就可以在TypeScript文件中进行使用JQuery的语法\\ page.ts const teacher: string = \"kiven\"; console.log(teacher); $(function () { alert(\"kiven\"); }); 安装 types/jquery(解决方法) 第一种：就是安装别人写好的文件 npm 进行安装。 npm i @types/jquery 第二种:简单粗暴page.ts 直接在page.ts文件的头部加入这句代码： declare var $: any; 第三种：自己写一个.d.ts声明文件的类库 tsconfig.json 生成 tsconfig.json 文件 终端 输入 tsc --init 用来配置如何对ts文件进行编译的 typescript 的编译配置文件。 demo.ts const person: string = \"kiven\"; 直接运行tsc命令，这时候tsconfig.json才起作用 ·tsconfig.json \"removeComments\": true, //生成js 文件是否附带注释 include 、exclude 和 files 只编译 一个固定文件 使用 include 配置 tsconfing.json { \"include\":[\"demo.ts\"], \"compilerOptions\": { //any something //........ } } 使用 exclude 配置 { \"exclude\":[\"demo2.ts\"], \"compilerOptions\": { //any something //........ } } include是包含的意思，exclude是不包含 使用 files 配置 { \"files\":[\"demo.ts\"], \"compilerOptions\": { //any something //........ } } compilerOptions 配置项 removeComments 属性 设置为true在js中不显示注释。 strict 属性 strict属性如果设置为true,要按照TypeScript最严格的规范来写 noImplicitAny 属性 noImplicitAny属性的作用是，允许你的注解类型 any 不用特意表明 设置为noImplicitAny:true,意思就是值就算是 any（任意值），你也要进行类型注释。 function Kiven(name: any) { return name; } strictNullChecks 属性 strictNullChecks设置为false,它的意思就是，不强制检查 NULL 类型。 const kiven: string = null; 配置了“不强制检验 null 类型”。如果你设成strictNullChecks:true，这时候就报错了。 rootDir 和 outDir 工作中我们希望打包的js都生成在特定的一个文件夹里,比如build。 这时候你就可以通过配置outDir来配置 所有的 ts 文件都放到 src 下 配置文件就应该这样写。 { \"outDir\": \"./build\" , \"rootDir\": \"./src\" , } sourceMap 属性 Source map 就是一个信息文件，里面储存着位置信息。 也就是说，转换后的代码的每一个位置，所对应的转换前的位置。 有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码 noUnusedLocals 和 noUnusedParameters 开启noUnusedLocals：true，开启后我们的程序会直接给我们提示不能这样编写代码，有没有使用的变量。 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 21:49:43 "},"Front-end Framework/BootStrap/":{"url":"Front-end Framework/BootStrap/","title":"BootStrap","keywords":"","body":"BootStrap 响应式布局(CSS3) 什么是响应式网页 响应式网页必须做到的几件事 :::tip 布局，使用流失布局(默认文档流+浮动)+弹性布局+栅格布局 文字可图片大小随着容器大小改变 媒体查询技术(css3) 代码复杂程度几何性增加 复杂网页，不适合使用响应式布局 ::: 如何测试响应式网页 使用真实设备 :::tip 好处: 真实可靠 缺点: 成本高，测试任务量巨大 ::: 使用第三方模拟软件测试 :::tip 好处: 方便，快捷 缺点: 测试效果有限，有进一步验证 ::: 编写响应式布局 手机适配 视口的设置，如果项目需要在移动端运行，需要设置视口 width=device-width 设置视口宽度等于设备宽度 initial-scale=1.0 设置视口宽度初始能不能缩放 1.0代表不能缩放 maximum-scale=1.0 设置视口最大缩放比例 1.0最大1倍 user-scalable=0 设置是否允许用户缩放视口 0不允许 视口最简介的写法 所有的内容/文字/图片都使用相对尺寸(尽量)，少使用绝对值 流式布局 + 弹性布局 + 媒体查询(栅格布局) 完成响应式布局 媒体查询 CSS3 Media Query 做响应式必备技术 Media: 媒体，浏览网页的设备 设备: screen(pc/pad/phone) TV/print 根据浏览器网页的设备不同(尺寸，方向，硬件，解析度等)有选择的执行一部分 css 样式，忽略其它 css 样式 BootStrap :::tip BootStrap地址 ::: 如果使用 boot container 定宽容器，每种不同的分辨率下，定义了写死的 max-width 同时，左右 15px 内边距，水平居中 container-fluid 变宽容器，根据不同分辨率的屏幕，宽度永远是屏幕的 100% :::tip boot 支持 4 种屏幕 xl/lg/md/sm 不支持 xs boot 中 1 个 rem 是 16px boot 的 css reset 使用的是 normalize 方案 ::: 按钮相关 css /* .btn 基本类 定义了行内块，字号，文本对齐，边框，过渡等 按钮颜色 */ .btn-danger 红色 .btn-success 绿色 .btn-warning 黄色 .btn-info 藏青 .btn-primary 蓝色 .btn-secondary 灰色 .btn-dary 深色 .btn-light 浅色 不同边框的颜色 .btn-outline-danger/warning/info..... 不同按钮大小 .btn-sm 小的 .btn-lg 大的 .btn-block 块级 .btn-link 链接 图片相关 .rounded /* 添加圆角 0.25rem */ .rounded-cirle /* 圆形 */ .img-thumbnail /* 添加内边距和边框 */ .img-fluid /* 响应式图片，图片可以缩放，但是图片不能超过原始图片大小 */ 文字相关 class .text-danger/warning/info.... 文本颜色 .h1~h6 文字字号加粗 .text-uppercase/text-lowercase/text-capitalize 文本大小写，首字母大写 .text-left/right/center 文本对齐 .text-*-left/right/center *: sm/md/lg 媒体查询 .text-justify 两端对齐，没有媒体查询 列表相关 ul .list-unstyled 去点，左内边距清 0 .list-group 列表组 li .list-group-item 列表项，边框，首元素和尾元素的圆角 颜色 .list-group-item-danger/warning.... 激活项 .active 禁用项 .disabled table 相关 class .table 对 table 本身和 table 的后代布局 .table-bordered 为 table 本身和后代添加边框 .table-danger/warning/success... 表格颜色 .tbale-hover 带悬停效果的表格 .table-striped 各行换色 .table-responsive-* *: sm/md/lg/xl 响应式布局的表格，写在 table 的付元素上 辅助类 边框 ```css .border-0 去掉边框 .border-top/right/bottom/left-0 去掉某一个方向的边框 基本类 .border 灰色实线边框 .brder-top/right/bottom/left 单边的灰色实线边框 边框颜色 .border-danger/warning/success.... - 浮动 ```css .float-left/right/none 响应式浮动 .float-*-left/right/none *: sm/md/lg/xl .clearfix 解决高度坍塌，写在父元素上 显示 .visible visibility: visible .invisible visibility: hidden 背景颜色 bg-danger/warning/success..... 圆角 .rounded/.rounded-0 .rounded-top/right/bottom/left 设置某个方向的两个圆角 尺寸 ```css w-25/50/75/100 width: 25%/50%/75%/100% 其它宽度需要自己定义 h-25/50/75/100 height: 25%/50%/75%/100% - 内外边距 ```css m/mt/mr/mb/ml/mx/my-*-auto/0/1/2/3/4/5 外边距 0: 0rem 1: 0.25rem 2: 0.5rem 3: 1rem 4: 1.5rem 5. 3rem p/pt/pr/pb/pl/px/py-*-0/1/2/3/4/5 内边距 *: sm/md/lg/xl 响应式的内外边距 栅格布局 table 布局 div + css boot 的栅格 简单，容易控制 语义正确，渲染效率高 简单，容易控制，语义正确，渲染效率高，支持响应式 语义错误，渲染效率底 控制起来很麻烦，尤其是响应式布局找那个 非常复杂的页面，不建议使用 栅格概念 :::tip 我们把每一行布局，分成 12 份 元素的占地面积，靠份数定义 ::: 栅格的属性 ```css 必须放在 .container 或者 .container-fluid 中 每一行 row，弹性，主轴 x，可以换行，有 -15px 的左右外边距 使用 .col-n，来声明子元素在 row 中占几份 所有 col 自带左右 15px 的内边距 - 响应式的栅格布局 ```css col-*-n *: xl/lg/md/sm n: 1-12 在不同屏幕下，占一行的 n 份 ex: col-lg-3 col-sm-6 :::warning 注意: .row 的 -15px 左右外边距和 .col 的 15px 左右内边距，会导致布局对不齐，项目中要进行处理 ::: .col :::tip 使用 .col 类，不添加数字，自动布局，没有个 col 平均分配空间，col 可以超过 12 个，并且不换行 ::: boot 媒体查询的兼容性问题 boot 中的媒体查询，小屏幕向大屏幕兼容 sm 兼容 md/lg/xl md 兼容 lg/xl lg 兼容 xl 列偏移 .offset-*-n *: sm/md/lg/xl n: 0~11 col 向右偏移 n 份 栅格嵌套 :::tip 请在 col 中单独写出 div.row ::: 弹性布局 d-*- none/inline/block/inline-block/flex /* 主轴方向 */ flex-*-row/row-reverse/column/column-reverse /* 项目在主轴上的排列方式 */ justify-content-*-between/around/start/end/center 表单 表单元素的排列方向 .form-group /* 堆叠表单，垂直排列 */ .form-inline /* 内联表单，水平排列(弹性) */ 表单控件样式 ```css .form-control input 元素的基本类 / 块级 w100 字体 背景 边框 过渡 / .col-form-label/-sm/-lg 设置输入文本与边框的距离 对于 checkbox 的样式 父级 .form-check (相对定位) 子级 .form-check-input (绝对定位) .form-text 0.25 上外边距，块级 ## 常用组件 - 按钮组 ```css 基本结构 div.btn*n 外层 div 添加类 btn-group 横向按钮组 btn-group-vertical 纵向按钮组 使用 btn-group-lg/sm 调整按钮大小 按钮组 小鸡炖蘑菇 姜丝炒土豆丝 锅肉包 下拉菜单 ```css 样式 div.dropdown 相对定位 button.dropdown-toggle 画向下的小三角 ul.dropdown-menu display: none; 事件 button data-toggle=\"dropdown\" 以 dropdown 的方式切换 事件目标: ul 由于和 button 被 div.dropdown 包裹，点击 button，自动会更改 ul 的状态，不需要单独写目标 ``` 信息提示框 ```css 样式 div.alert.alert-info alert 基本类 alert-danger/info...颜色 .alert-dismissble 配合子元素的 .close 类使用 span.colse 取消的小叉叉右浮动 事件 给 span (小叉叉)添加自定义属性 data-dismiss=\"alert\" 事件目标不用写，默认是 span 的元素 div.alert 总结: boot 中事件，关注两件事 事件是如何触发的。自定义属性触发，触发方式是这个属性的值 事件触发的目标 button 绑定事件 data-target=\"#id\" a 绑定目标 href=\"#id\" ``` 导航 ```css 水平导航 ul.nav 弹性布局，去点，主轴方向默认 X 轴 li.nav-item 配合 ul.justified 让 li 等宽显示 a.nav-link 块级，内边距撑开，hover，focus等 选项卡导航 导航样式 ul.nav.nav-tabs>li.nav-item>a.nav-link .nav-tabs 让水平导航变成选项卡导航 显示内容样式 div.tabs-cintent>div.tabs-pane div.tabs-cintent 没有任何样式，作为子代选择器的路径 div.tabs-pane 与父元素配合，让当前元素 display: none .active 与 .tabs-content 配合，让当前元素显示 事件 111 给 div.tab-pane 添加 id 把 id 放到对相应的 a 标签中定义事件触发之后，执行的目标 胶囊导航 ul.mav.nav-pills li.nav-item a.nav-link data-toggle=\"pill\" href=\"#对应id\" 内容 div.tab-content>div.tab-pane ``` 导航栏(重点) div.navbar.navbar-expand-* ul.navbar-nav 默认为弹性，主轴为 y 父级 div 的 navbar-expand-* 与子级 ul.navbar-nav 组成后代选择器，对 ul 的主轴方向进行了控制 比如 navbar-expand 导尿管屏幕 w>=768px,ul 的主轴方向变为 row ，所有 li 横向显示。当屏幕 w 折叠 button data-toggle=\"collapse\" data-target=\"div的id\" div.collapse display: none 隐藏 卡片 div.card > div.acrd-header div.card-body div.card-footer /* 如果在 card 中有 a 标签, 那么 a 可以使用 card 提供的样式 .card-link 对于一个 card 来说，处理 div.card, 其它都可以省略 */ 手风琴(卡片+折叠) 手风琴 卡片1 内容1 卡片2 内容2 :::warning 注意: .collapse 不能和 .card-body 在同一个 div 上，不然在隐藏/显示的时候，会发生卡顿 解决方案 div.collapse>div.card-body 多个折叠部分可同时打开 解决方案: 在最外层，添加 div#parent, 所有的卡片都在这个 div 中，在所有 div.collapse 上，添加事件 data-parent=\"#parent\", 这样就可以保证，在 div#parent 中，同时最对只能有一个折叠区域是打开状态 ::: 折叠导航栏 ```css 最外层 navbar.bg-dark.navbar-dark.navbar-expand-* 内部 3 部分 a.navbar-barnd 不隐藏，显示在最前面的菜单 button.navbar-toggle > span.navbar-toggle-icon 折叠按钮 div.collapse.navbar-collapse 折叠的菜单项 ul.navbar-nav > li.nav-item > a.nav-link 功能解释 .navbar-dark 对最外层 div 没有任何影响，告诉内部的 .navbar-barnd 和 .navbar-nav 和 .navbar-toggle-icon 告诉它们，导航栏是深色的，你们要用浅色文字 .navbar-expand- 和 .navbar-collapse 配合 .collapse 作用 dispaly: none; .navbar-expand- .navbar-collapse{dispaly: flex} / 所以只要屏幕符合 号要求，这里的 div 就是显示状态，屏幕不符合 号要求，那么这个选择器就失效了，所以这里的 决定了菜单在什么屏幕下显示，什么屏幕下隐藏 */ ``` 媒体对象 媒体对象 齐胸襦裙 很受欢迎 焦点轮播 ```cs 图片轮播 div.carousel 相对定位 div.carousel-inner 相对定位 宽100% 溢出隐藏 div.carousel.item.active display: none .active 显示 img.w-100 如果宽度不是 100% 右箭头会走出去 事件 给 div.carousel 添加 data-ride=\"carousel\" 轮播图就可以动了 左右箭头 div.carousel#id a.carousel-control-prev/next data-slide=\"prev/next\" href=\"#id\" 由于 boot 给默认的左右箭头不符合我们的需求所以样式需要重写 轮播指示器 ul.carousel-indicators 定位，弹性布局 li.active .carousel-indicators 设置了 li 的宽高，由于 boot 宽高不符合我们的需求，需要重写(看ui设计) 事件 li data-slide-to=\"图片的index\" 从 0 开始 data-target=\"#id\" ``` 模态框 模态框 start modal 信息收集 请输入姓名： 关闭按钮 其它组件 巨幕 巨大的内边距，和边框，背景色 div.jumbotron 徽章 把徽章看作小按钮 基本类 badge 徽章颜色 badge-danger/warning.... 胶囊徽章 badge-pill Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"Front-end Framework/BootStrap/OtherComponents.html":{"url":"Front-end Framework/BootStrap/OtherComponents.html","title":"其它组件","keywords":"","body":"其它组件 分页 ul.pagination >li.page-item >a.page-link li 的修饰类 .active 激活 .disabled 禁用 面包屑 ul.breadcrumb > li.breadcrumb-item 中间的连接符号可以自己定义 .breadcrumb-item + .breadcrumb-item::before {content: \">\";} 进度条 div.progress 进度条的槽 > div.progress-bar 进度条的进度需要自己写宽度 背景 bg-danger.... 带条纹的进度条 progress-bar-striped 带动画的进度条 progress-bar-animated BootStrap 重点: 响应式 + 栅格 + SCSS Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"Front-end Framework/BootStrap/SCSS.html":{"url":"Front-end Framework/BootStrap/SCSS.html","title":"SCSS","keywords":"","body":"SCSS css 是一种脚本语言，没有动态语言特征 css 语法不够强大，没有变量和合理的样式服用机制，导致难以维护 我们需要使用动态的 样式语言，赋予 css 新的特性 常见的动态样式语言 scss/sass(scss 兼容 sass，scss 跟接近 css 语法) stylus less scss 的功能 scss 是一款强化 css 的辅助工具 它和 css 语法很象，在 css 的基础上增加了变量，嵌套，混合，导入，函数等高级功能。这些扩展，让 css 更加的强大优雅 scss 运行在服务端 浏览器不认识 .scss 文件，需要转换成 .css 才能被浏览器解析执行 scss 的使用 scss 是在服务端使用 安装 nodejs 的解析器 v8.11.1 以上 在线安装 cmd 控制台输入 npm install -g node-sass 无网安装 把安装包中的文件，复制到 nodejs 安装目录下 :::tip cmd 中输入 node-sass -v 检查版本号 打印出版本号，就是成功 ::: scss 文价转换成 css 文件 单文件转换 在项目目录下，按住 shift，右键打开 powershell 输入 node-sass scss/01.scss css//01.css 要转换的scss文件 转换后的css文件 对文件转换 node-sass scss -o css node-sass scss文件夹名称 -o css文件夹名称 单文件的监听 node-sass -w scss/01.scss css/01.css 开启一个监听，注视这 01.scss 文件 一旦这个文件保存,自动转换成 01.css文件 多文件监听 node-sass -w scss -o css scss 基础语法 变量 使用 $ 符号创建变量，变量名可以包含 - _ 命名规则基本与 css 选择器相同，尽量做到见名知意 :::warning注意: 变量声明时，可以引用其它变量 变量如果声明在 {} 内，就只能在这个 {} 内使用 !default 规则 如果此变量之前声明过值，就使用之前声明的变量 如果此变量之前没有声明过值，就是用现在的值 $jd_red: red !default; ::: 嵌套 后代选择器的嵌套写法 伪类选择器的嵌套 .mybtn { &:hover{} } // 嵌套需要 & 占位符，如果没有占位符，选择器和伪类选择器之间会多一个空格，导致选择器整个失效 群组的嵌套 nav, div, h1 { a { color: #fff; } } 属性的嵌套 div { border: { style: solid; width: 10px; color: #fff }; } 导入 在 scss 语法中。如果 scss 文件，以下划线，那么这个 scss 就别称为局部 scss 文件 局部 scss 文件的特点 :::tip 每一个局部 scss 文件，就是一个小模块 scss 在转换 css 的时候，不会转换局部 scss 文件 我们一般会在全局 scss 文件中，导入局部 scss 文件 导入的语法 @import 局部 scss 文件名称(不带下划线，不带后缀名)这样生成一个统一的 css 文件 导入局部 scss 中的变量，可以在被导入的文件中使用 ::: 混合器 :::tip 把多个选择器都会用到的样式，封装进一个混合器中 需要使用的时候，调用混合器，实现代码的重用 声明混合器 @mixin 混合器名称(参数1, 参数2,....) {样式} 调用混合器 @include 混合器名称(实参1, 实参2,...) ::: :::warning 注意: 混合器使用最多的场合，css hack ::: 继承 :::tip 一个选择器，可以完全使用另外一个选择器的样式 使用关键字 @extend 选择器名; 继承样式 ::: 运算符 + - * / % scss 可以自动在几种单位之间转换数值 前提是，单位可以转换 rem em %就不能转换 加法 :::tip 字符串拼接的时候，如果使用有双引号的 + 无双引号的，结果有双引号 如果使用无双引号 + 又双引号，结果无双引号 ::: 减号 :::tip 减号会被自动解析为变量的一部分 所以 scss 中减法，要前后加空格 ::: 除法 :::tip scss 中 / 的作用，除法，分隔符 在 scss 中，以下情况会被认为是除法 如果运算符两边的数字 是变量或者函数的返回值 运算式被小括号包裹，是除法 除法运算式，是其它算术运算的一部分 ::: 字符串的插值操作 content: \"liangliang ate #{200 + 100} baozis\" #{} 做插值 颜色运算 // 分段运算 #rrggbb + #rrggbb = #rr+rr gg+gg bb+bb rgb(a,b,c) + rgb(d,e,f) = rgb(a+b, b+e, c+f) rgba //的算法 // 计算两个 rgba 的时候，要求 alpha 必须相等，才能运算 内置函数 // scss 定义了很多函数，有些函数直接可以在 css 语句中使用 // 1. rgba 就是 scss 函数 hsl(hue, saturation, lightness) hue 色调 0~360 0~120 120~240 240~360 saturation 饱和度 0~100% lightness 亮度 0~100% // 2. 数学函数 round($val) // 四舍五入 ceil($val) // 向上取整 floor($val) // 向下取整 min($v1, v2...) // 最小值 max($v1, $v2..) // 最大值 random() // 随机数 // 3. 字符串函数 unquote($str) // 去掉 $str 的引号 quote($str) // 加上 $str 的引号 to-upper-case(\"abc\") // 变大写 to-lower-case(\"ABC\") // 变小写 // 4. 自定义函数 @function get-width($a, $b) { @return min($a, $b); } // 关键字 function return 加 @ 参数加 $ 指令 @if ($type == sum) { color: red; } @else if ($type == moon) { color: blue; } @else { color: orange; } // 条件的小括号，可加，可以不加 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-08-30 12:38:57 "},"Website collection/":{"url":"Website collection/","title":"网站收集","keywords":"","body":"网站收集 编辑器/IDE [!NOTE|style:flat] Visual Studio Code Webstorm Webstorm Atom HBuilder Vim Notepad++ HBuilderX Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 14:04:56 "},"Website collection/tools.html":{"url":"Website collection/tools.html","title":"工具","keywords":"","body":"工具 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 13:41:57 "},"Website collection/content.html":{"url":"Website collection/content.html","title":"合集","keywords":"","body":"合集 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 13:39:13 "},"Website collection/open_source_lib.html":{"url":"Website collection/open_source_lib.html","title":"开源库","keywords":"","body":"开源库 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 13:42:20 "},"Website collection/shu_dan.html":{"url":"Website collection/shu_dan.html","title":"书单","keywords":"","body":"书单 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 13:42:57 "},"Interview questions/":{"url":"Interview questions/","title":"面试题","keywords":"","body":"面试题 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-02 19:06:24 "},"Demo/":{"url":"Demo/","title":"Demo","keywords":"","body":"Demo [!Tip|style:flat] 持续更新中...，欢迎大家投稿😘😘😘。 简述 [!warning|style:flat] 一些前端的小功能 还有一些小游戏 有自己喜欢的小 Demo 都可以联系我们，提一些 issues 在提交 issues 前，请详细说明自己的需求. 网页小 demo 名称 演示/demo 描述 null null null 网页小游戏 名称 演示/demo 描述 null null null Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 12:50:48 "},"About us/":{"url":"About us/","title":"关于我们","keywords":"","body":"关于我们 我们欢迎所有要求。 也欢迎在 此处 提出建议和反馈。 加入讨论 Aftersoil --> GitHub Issues --> 友情链接 [!Tip|style:flat] https://blog.chibamai.xyz/ 【千叶麻衣 Blog】 https://kivenblog.fit/ 【Welcome to KivenBlog】 贡献者 贡献者 贡献内容 贡献者 贡献内容 GitHub null blog null 持续更新，仍有更多内容尚未完善，欢迎大家投稿。 Chiba Mai © ibooker.org.cn 2020 all right reserved，powered by Gitbook该文件修订时间: 2021-09-01 00:44:49 "}}